2010年 08月 11日 星期三 20:15:42 CST
/data/system/packages.xml is the information about the installed packages.  It is read and written by PackageManagerService.xml.  It is far more than just permissions.
btrfs ZFS
Bluetootheventloop.cpp

emulator  power off的问题
emulator总是一启动就自动关机，可以通过修改BatteryService.java中的下面的参数来解决 
mBatteryStats.setOnBattery(mPlugType == BATTERY_PLUGGED_NONE, mBatteryLevel);
intent.putExtra("level", mBatteryLevel);
将mBatteryLevel写成固定值为100，不让其为0

out/host/linux-x86/bin/aapt package  -M packages/apps/SpeechRecorder/AndroidManifest.xml -S packages/apps/SpeechRecorder/res     -F out/target/product/generic/obj/APPS/SpeechRecorder_intermediates/package.apk | tee trace.txt


$adb shell input keyevent 82
lockscreen 解锁

备份文件好方法
find frameworks/base  -ctime  0 -type f  -print0 | xargs -0 -i cp {}  ../xusldev/binder-bk/


Android UI design reference
http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html
http://xebee.xebia.in/2010/10/20/android-ui-development-tools/?utm_source=twitterfeed&utm_medium=twitter
http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html
http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html
http://www.droiddraw.org/androiddraw.html
http://www.fluffyspider.com/
http://code.google.com/p/android-ui-utils/
http://www.smashingmagazine.com/2009/08/18/android-gui-psd-vector-kit/
http://www.droiddraw.org/

http://androidappdocs.appspot.com/guide/practices/ui_guidelines/index.html




strace is a tool which intercepts and describes all interaction between user-side processes and the Linux kernel. You could enhance it also to understand the Binder ioctls which are used for most Android IPC. This will report on intent delivery, service binding and virtually any other Android IPC.

You will have to do quite a bit of work to make strace work in this way. There's a patch here where I started this work in 2009. I seriously doubt that this would apply to modern versions of strace, and in any case I didn't get very far, but it might be somewhere to start.
http://www.macrobug.com/opensource/strace/



OOM => out of memory


	Killing apps in Android
I am trying to implement some task manager like app in android. The problem is
that I am able to kill the app process by calling Process.sendSignal(pid,9)
but after that the screen of the app stays.


==================================================================
Re: iptables
I got it!

a crucial netfilter config was missing

CONFIG_NETFILTER_XT_MATCH_OWNER=m

Once that was in, everything worked like a charm!


---->
Is that because the linux kernel was not compiled with CONFIG_NETFILTER_XT_MATCH_OWNER option so that the netfilter cannot do anything with OWNER option ?
<-----
correct.
that option should be configured, along with other extensions you may
need.

Intercepting all network access calls
the iptables solution works perfectly.
Just so that this may help someone in the future.


When I enable -Xjitverbose, I see that traces along with the assembly
generated gets printed. To my surprise I also see that same traces are
compiled by the JIT compiler and a duplicate code copy is installed in
code cache at multiple locations.

My question is does/does not the JIT compiler check if a particular
trace is compiled before compiling it ? If it does check, why do I see
duplicate codes in the verbose mode ? And also where does it check ?
===========================JIT==========================================
FROM TOPICS JIT enabling for armv5te
you can get from dalvkit/vm


ifeq ($(TARGET_ARCH_VARIANT),armv5te)
    WITH_JIT := false
endif
Although we monitored the JIT resource consumption closely, it still adds one compiler thread and a couple hundred KBs of code cache to each process, which might be a burden to lower-end devices. Since the CPU frequency for v5te cores and RAM amount vary from platform to platform, we decided to disable the JIT for v5te by default in the makefile, but platform developers can easily enable it once the underlying system is measured to be fast enough. 
Glad you mentioned the device boot time. The Dalvik VM uses the interpreter to make forward progress unless frequently executed code traces are detected, and the JIT will only help the performance if the majority cycles are spent in the VM interpreter. The boot process happens to execute code from a relatively large footprint with low repeat rates, and less than 30% of the cycles are in the VM to begin with, so "exactly the same time" is the expected behavior.


The transition from the interpreter to the JIT compiler can be tuned via the parameters in the ArchVariant.c file under dalvik/vm/compiler/codegen/arm/<arch>. For example, currently armv5te says:


    gDvmJit.threshold = 200;
    gDvmJit.codeCacheSize = 512*1024;


That is, only traces that are executed more than 200 times before are considered JIT-worthy, and the upper-bound for the code cache size for each process is 512K. If the underlying CPU is not fast enough and the threshold is set too low, the device may feel sluggish since the compiler threshold is using the CPU more often. Also if RAM is not abundant on the device while the code cache size is too big, the overall system performance may degrade due to memory contentions. The sweet-spot setting for different devices (especially for lower-end ones) varies and some benchmarking effort is probably required.


That said, for CPU intensive workloads both the v5te and v7 JIT will provide significant speedups over the base line, but the actual ratio varies case by case and you can look at our I/O presentation on how to use profiling tools to find out  the expected behavior. Lower-end devices are more sensitive to the JIT parameters and may require individual tuning, so the JIT is disabled by default for the v5te target.
====================================================================================

Event dispatching is implemented in Java code, and received by the application in ViewRoot.  And yes, as I've said, you can just use JNI to execute some native code.  That native code can do whatever native code can do.  You can call your kernel module or whatever at that point.


installPackage()
PackageManagerService.grantPermissionsLP()
checkPermission() is basically the implementation of checkCallingOrSelfPermission().

These are defined in /system/etc/permissions/framework.xml (or any other file in the directory).
The only way to temporarily remove a uid from a gid is by changing the framework to allow you to remove a permission from an app, and kill any processes running under its uid.

Each package in there has a HashSet of permissions.  If you search through the file for the permission structures, you will find them.


ActivityManagerService
|
|_enforceCallingPermission() -> checkCallingPermission() ->
CheckPermission -> CheckComponentPermission -> PAckageManagerService
 
|                                                                 |
 
|                                                                 |_
checkUidPermission()
 
|
ContextImpl.java = checkCallingPermission() -> checkPermission () _|

the checkUidPermission of the Package Manager has a Settings object =
HashMap<Name, PackageSetting>
PackageSetting has a "grantedPermissions" member which is a HashSet
and also a gids[] array.



"The Maestro’s two virtual serial ports can be used in Linux without
any special driver installation. The virtual serial ports are managed
by the cdc-acm kernel module, whose source code you can find in your
kernel’s source code drivers/usb/class/cdc-acm.c. When you connect the
Maestro to the PC, the two virtual serial ports should appear as
devices with names like /dev/ttyACM0 and /dev/ttyACM1 (the number
depends on how many other ACM devices you have plugged in). The port
with the lower number should be the Command Port, while the port with
the higher number should be the TTL Serial Port. You can use any
terminal program (such as kermit) to send and receive bytes on those
ports."


"putting your module in /system/lib/modules/ then insmod " is working fine but I am asking how to put in the ROM image so that I don't need to push the .ko file to /system/lib/modules

all java process all cloned from zygote ,


platform$ find . -name "*.java" | xargs grep --color -n -C 0 "implements\s*XmlPullParser"
./libcore/xml/src/main/java/org/apache/harmony/xml/ExpatPullParser.java:34:public class ExpatPullParser implements XmlPullParser {
./libcore/xml/src/main/java/org/kxml2/io/KXmlParser.java:33:public class KXmlParser implements XmlPullParser {


platform$ find sdk | xargs grep --color -n -e "android.libraries.res"
sdk/anttasks/src/com/android/ant/SetupTask.java:551:            antProject.addReference("android.libraries.res", resPath);
sdk/anttasks/src/com/android/ant/AaptExecLoopTask.java:368:        Object libSrc = taskProject.getReference("android.libraries.res");
sdk/anttasks/src/com/android/ant/AaptExecLoopTask.java:399:        Object libPath = taskProject.getReference("android.libraries.res");


sdk/anttasks/src/com/android/ant/AaptExecLoopTask.java:301:     private void callAapt(String customPackage) {
  

frameworks/base/libs/utils/AssetManager.cpp
frameworks/base/core/jni/android_util_AssetManager.cpp,
                         android_util_XmlBlock.cpp,
                         android_util_StringBlock.cpp
frameworks/base/core/java/android/content/res/AssetManager.java
frameworks/base/core/java/android/content/pm/PackageParser.java
frameworks/base/core/java/android/content/pm/PackageManager.java




**********************************************************************************
I tried to do a build of all required images (make -j4) with the
        kernel having been built based on android-msm-2.6.32, to be
        installed on a Nexus One, and I'm getting:
        
        error: out/target/product/passion/boot.img is too large (2439168 >
        [2703360 - 270336])

Open BoardConfig.mk file. Change partition size.
If you don't have below contents then insert this.


NEED to CHANGE PARTITION_SIZE !!!
=====================================================


BOARD_BOOTIMAGE_PARTITION_SIZE := 0x00500000
BOARD_RECOVERYIMAGE_PARTITION_SIZE := 0x00500000
BOARD_SYSTEMIMAGE_PARTITION_SIZE := 0x06900000
BOARD_USERDATAIMAGE_PARTITION_SIZE := 0x05000000
BOARD_FLASH_BLOCK_SIZE := $(BOARD_NAND_PAGE_SIZE) * 64
********************************************************************************
repo init; repo sync; lunch generic-eng; make; emulator

gives an engineering build.  Looking at the Config.java that is
generated, it seems to set the value as DEBUG = false; RELEASE =
false; in the build area.

Is the android.util.Config.Debug meant to be false in "eng" build ?
Shouldn't eng builds have logs turned on?

Looks like this is caused by the two seemingly conflicting variables,
TARGET_BUILD_VARIANT=eng and the TARGET_BUILD_TYPE=release, on the
default configuration.  What does it mean to say eng-release build?

http://android.git.kernel.org/?p=platform/build.git;a=blob_plain;f=core/build-system.html;hb=HEAD
does not have much details on these variables.



frameworks/base/tools/aapt/Android.mk
frameworks/base/tools/aapt/instrument.c
build/core/definitions.mk
build/core/config.mk
build/core/combo/HOST_linux-x86.mk
build/core/combo/select.mk

frameworks/base/cmds/bootanimation/BootAnimation.cpp

以前的????
frameworks/base/libs/surfaceflinger/BootAnimation.cpp

frameworks/base/cmds/bootanimation/BootAnimation.h
frameworks/base/cmds/bootanimation/BootAnimation.cpp
frameworks/base/core/res/assets/image/android-logo-shine.png
frameworks/base/core/res/assets/image/android-logo-mask.png

KGDB 跟架构有关，代码是 kgdb.c
如 arch/arm/kernel/kgdb.c
   arch/x86/kernel/kgdb.c
KDB
kernel/debug/kdb/kdb_main.c    汇编级调试

内核
init/do_mounts.c
init/do_mounts_md.c
init/do_mounts_initrd.c
init/initramfs.c
usr/initramfs_data.s
usr/gen_init_cpio.c


内核启动时的logo
drivers/video/logo/*.ppm


system/core/include/cutils/atomic.h

system/core/init/parser.c
是 init 启动脚本的解析器，如 /init.rc  /init.${hardware}.rc
(如/init.goldfish.rc)
其语法参见：
system/core/init/readme.txt

system/core/init/init.c
main 函数 寻找 目标文件系统中的文件 /init.logo.rel
load_565rle_image(INIT_IMAGE_FILE)
system/core/init/init.h
#define INIT_IMAGE_FILE	"/initlogo.rle"

如果装载logo失败，则向/dev/tty0打印 "             A N D R O I D "字符串。



dalvik\vm\analysis/CodeVerify.c

libcore/dalvik/src/main/java/dalvik/system

文件系统操作监控, 对 inotify 的封装。
frameworks/base/core/java/android/os/FileObserver.java
frameworks/base/core/jni/android_util_FileObserver.cpp

libdvm   library dalvik virtual machine
dalvik/vm/Android.mk

===begin
> I think the portable interpreter is not the one being used by the
> emulator.

By default, the "fast" interpreter is used, and (in >= froyo) the JIT
is enabled.

You can provide "-Xint:portable" on the command line, or "setprop
dalvik.vm.execution-mode int:portable" to change the way the
interpreter used by the Android app framework (the latter requires
root, and you must stop/start the framework after changing the
property).

You could also just modify dvmLockObject(), which is where most of the
interesting stuff happens, though that won't get called if the JIT is
inlining thin lock activity (in which case you still need to specify
the portable interpreter).
===end

onSaveInstanceState(Bundle) is not called
Think of the bundle in onSaveInstanceState as a place to put data that would be needed to recreate an activity. As it turns out, activities are destroyed and recreated quite frequently -- even when you might not expect it, but an activity is only 'finished' once. 

One example of this is when the phone is rotated. At this time, the activity is destroyed and then a new one is created. Android will give you an opportunity to save data from the activity to pass to this new instance. This same sort of behavior happens when the system is running low on memory. Imagine you have four activities on the history stack: A -> B -> C -> D. Maybe by the time you hit activity D, the system's running low on memory. At this point, dalvik might destroy A, calling onSaveInstanceState on it. If you hit back from D, then to C, then to B, then to A again, it will recreate the activity from the data you stored in the bundle. 

In contrast, an activity is 'finished' when it will never be reshown. For example, if the user hits the back button from that activity.

============================
Thanks, very helpful.

So, if activity is actually finish, then we need to save the information in the SD Card before it destroyed in order to use that information in the future when application is started again,right ?

Is there any conventional way for saving application data in the SD , where to place the file,which file type(xml,etc)?


SharedPreference!!


Re: JIT performance through checkers
According to the author of the game they represent the following meanings: 

v : evaluation value of position after search
d : total depth of search tree (using iterative deepening from d=1 up, stops when out of time)
n : number of nodes in the search tree 

We treat 'n' as the benchmark score.





Indeed, the Settings app is very much a "platform-only" app that uses
non-public APIs and therefore cannot be built outside of the entire
Android source tree.



frameworks/base/core/jni/android_ddm_DdmHandleNativeHeap.cpp
dalvik/vm/alloc/HeapWorker.c

libcore/luni-kernel/src/main/java/java/lang/Runtime.java
freeMemory， maxMemory， totalMemory
traceMethodCalls =》 VMDebug.stopMethodTracing();/VMDebug.startMethodTracing();

libcore/luni-kernel/src/main/java/java/lang/System.java

                // Trigger a gc to try to clean up after the stuff is done, since the
                // renderscript allocations aren't charged to the java heap.
                mHandler.post(new Runnable() {
                        public void run() {
                            System.gc();
                        }
                    });

System.loadLibrary
System.setProperty("qwerty", "1");

libcore/dalvik/src/main/java/dalvik/system/VMRuntime.java
在 Application 或 Activity 创建时设置：
      VMRuntime.getRuntime().setMinimumHeapSize(4 * 1024 * 1024);
dvmAttachCurrentThread in Thread.c
startJitCompilation
gdbjithelper

frameworks/base/core/java/android/os/Debug.java
frameworks/base/core/java/android/os/Build.java    //有关编译时的信息。

dalvik/dalvikvm/main.c
dalvik/vm/jdwp/*,   如 Debugger.c
JDWP: Java Debug Wire Protol
dalvik/vm/Interp.c    Breakpoint, BreakpointSet
dalvik/docs/debugger.html
/home/leo/android/platform/development/tools/jdwpspy

libcore/dalvik/src/main/java/dalvik/system/Zygote.java

frameworks/base/core/jni/android_media_ToneGenerator.cpp

在android中，屏幕(framebuffer)被看成为一个device，文件/sys/power/wait_for_fb_sleep和 /sys/power/wait_for_fb_wakeup被kernel用来通知framework屏幕挂起或恢复了。在framework中有两个线程，一个是画图的主线程，在循环中它会首先检查kernel的事件通知信号并设置framebuffer是否可画，下面是示意性的framework代码：

1 . surface flinger thread:    
while ( true ) {    
    checkEventAndSendSignal();    
    doSomeThing();    
     if  (canDraw) {    
        swapBuffer();    
    }    
}    
2 .check event function    
checkEventAndSendSignal() {    
     if  (wait_for_sleep  returned) {    
        canDraw =  false ;    
        mBarrier.open();    
    }    
     if  (wait_for_wakeup returned) {    
        canDraw =  true ;    
    }    
}    
3 .drawing function    
swapBuffer() {    
    .....    
    ioctl(egl_native_window_t::fd, FBIOPUT_VSCREENINFO, &mInfo)    
     ....    
}    
4 .getEvent thread    
while ( true ) {    
    wait_for_sleep();    
    sendSleepReturnEvent();    
    mBarrier.wait();    
   wait_for_wakeup();    
  sendWakeupReturnEvent();    
}   
当屏幕可用时，kernel会block getEvent线程在wait_for_sleep(read(wait_for_fb_sleep file))调用上，直到屏幕不可用(用户关闭屏幕，变黑)；当屏幕不可用（挂起），kernel会block getEvent线程在wait_for_wakeup(read(wait_for_fb_wakeup file))调用上，直到屏幕可用。

在挂起屏幕前（wait_for_wakeup）mBarrier用来同步surfaceflinger线程画完上次循环未完成的framebuffer

frameworks/base/core/jni/android_view_Surface.cpp, android_view_Display.cpp
surfaceflinger/SurfaceComposerClient.h
frameworks/base/libs/surfaceflinger/*
                     surfaceflinger_client/*


sdk/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/launch/AndroidLaunchController.java:978:        String message = String.format("Installing %1$s...", launchInfo.getPackageFile().getName());
sdk/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/launch/AndroidLaunchController.java:1541:                                "Attempting to connect debugger to '%1$s' on port %2$d",

[2010-08-16 13:50:52 - EX03_01] Refreshing resource folders.
[2010-08-16 13:50:52 - EX03_01] Starting incremental Pre Compiler: Checking resource changes.
[2010-08-16 13:50:52 - EX03_01] Nothing to pre compile!
[2010-08-16 13:50:52 - EX03_01] Starting incremental Package build: Checking resource changes.
[2010-08-16 13:50:53 - EX03_02] Refreshing resource folders.
[2010-08-16 13:50:53 - EX03_02] Starting incremental Pre Compiler: Checking resource changes.
[2010-08-16 13:50:53 - EX03_02] Nothing to pre compile!
[2010-08-16 13:50:53 - EX03_02] Starting incremental Package build: Checking resource changes.
[2010-08-16 13:50:53 - EX07_04] Refreshing resource folders.
[2010-08-16 13:50:53 - EX07_04] Starting incremental Pre Compiler: Checking resource changes.
[2010-08-16 13:50:53 - EX07_04] Nothing to pre compile!
[2010-08-16 13:50:53 - EX07_04] Starting incremental Package build: Checking resource changes.
[2010-08-16 13:50:59 - EX07_04] ------------------------------
[2010-08-16 13:50:59 - EX07_04] Android Launch!
[2010-08-16 13:50:59 - EX07_04] adb is running normally.
[2010-08-16 13:50:59 - EX07_04] Performing irdc.EX07_04.EX07_04 activity launch
[2010-08-16 13:50:59 - EX07_04] Automatic Target Mode: launching new emulator with compatible AVD 'sd'
[2010-08-16 13:50:59 - EX07_04] Launching a new emulator with Virtual Device 'sd'
[2010-08-16 13:51:00 - Emulator] emulator: WARNING: ignoring non-existing SD Card image
[2010-08-16 13:51:01 - EX07_04] New emulator found: emulator-5554
[2010-08-16 13:51:01 - EX07_04] Waiting for HOME ('android.process.acore') to be launched...
[2010-08-16 13:52:22 - EX07_04] WARNING: Application does not specify an API level requirement!
[2010-08-16 13:52:22 - EX07_04] Device API version is 8 (Android 2.2)
[2010-08-16 13:52:22 - EX07_04] HOME is up on device 'emulator-5554'
[2010-08-16 13:52:22 - EX07_04] Uploading EX07_04.apk onto device 'emulator-5554'
[2010-08-16 13:52:22 - EX07_04] Installing EX07_04.apk...
[2010-08-16 13:53:23 - EX07_04] Success!
[2010-08-16 13:53:24 - EX07_04] Starting activity irdc.EX07_04.EX07_04 on device 
[2010-08-16 13:53:26 - EX07_04] ActivityManager: Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=irdc.EX07_04/.EX07_04 }
[2010-08-16 13:53:27 - EX07_04] Attempting to connect debugger to 'irdc.EX07_04' on port 8631
[2010-08-16 14:38:39 - EX07_04] ------------------------------
[2010-08-16 14:38:39 - EX07_04] Android Launch!
[2010-08-16 14:38:39 - EX07_04] adb is running normally.
[2010-08-16 14:38:39 - EX07_04] Performing irdc.EX07_04.EX07_04 activity launch
[2010-08-16 14:38:39 - EX07_04] Automatic Target Mode: Preferred AVD 'oem' is available on emulator 'emulator-5554'
[2010-08-16 14:38:39 - EX07_04] WARNING: Application does not specify an API level requirement!
[2010-08-16 14:38:39 - EX07_04] Device API version is 8 (Android 2.2)
[2010-08-16 14:38:41 - EX07_04] Application already deployed. No need to reinstall.
[2010-08-16 14:38:41 - EX07_04] Starting activity irdc.EX07_04.EX07_04 on device 
[2010-08-16 14:38:43 - EX07_04] ActivityManager: Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=irdc.EX07_04/.EX07_04 }
[2010-08-16 14:38:45 - EX07_04] Attempting to connect debugger to 'irdc.EX07_04' on port 8631



启动时的堆栈
EX07_04 [Android Application]	
	DalvikVM[localhost:8631]	
		线程组 [system]	
			守护程序系统线程 [<3> Signal Catcher]（正在运行）	
			守护程序系统线程 [<2> HeapWorker]（正在运行）	
			线程组 [main]	
				线程 [<1> main]（已暂挂（断点位于 irdc.EX07_04.EX07_04 中的第 36 行）	
					<VM 不提供监视信息>	
					irdc.EX07_04.EX07_04.onCreate(android.os.Bundle) 行： 36	
					android.app.Instrumentation.callActivityOnCreate(android.app.Activity, android.os.Bundle) 行： 1047	
					android.app.ActivityThread.performLaunchActivity(android.app.ActivityThread$ActivityRecord, android.content.Intent) 行： 2627	
					android.app.ActivityThread.handleLaunchActivity(android.app.ActivityThread$ActivityRecord, android.content.Intent) 行： 2679	
					android.app.ActivityThread.access$2300(android.app.ActivityThread, android.app.ActivityThread$ActivityRecord, android.content.Intent) 行： 125	
					android.app.ActivityThread$H.handleMessage(android.os.Message) 行： 2033	
					android.app.ActivityThread$H(android.os.Handler).dispatchMessage(android.os.Message) 行： 99	
					android.os.Looper.loop() 行： 123	
					android.app.ActivityThread.main(java.lang.String[]) 行： 4627	
					java.lang.reflect.Method.invokeNative(java.lang.Object, java.lang.Object[], java.lang.Class, java.lang.Class[], java.lang.Class, int, boolean) 行： 不可用 [本机方法]	
					java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) 行： 521	
					com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() 行： 868	
					com.android.internal.os.ZygoteInit.main(java.lang.String[]) 行： 626	
					dalvik.system.NativeStart.main(java.lang.String[]) 行： 不可用 [本机方法]	
				线程 [<6> Binder Thread #2]（正在运行）	
				线程 [<5> Binder Thread #1]（正在运行）	




leo@leo-desktop:~/android_2.1_20100506/android/frameworks$ find . -name ActivityManager*
./base/include/android_runtime/ActivityManager.h
./base/services/java/com/android/server/am/ActivityManagerService.java
./base/core/jni/ActivityManager.cpp
./base/core/tests/coretests/src/android/app/activity/ActivityManagerTest.java
./base/core/java/android/app/ActivityManagerNative.java
./base/core/java/android/app/ActivityManager.java
./base/tests/permission/src/com/android/framework/permission/tests/ActivityManagerPermissionTests.java


../build/tools/atree/atree.cpp:34:"                 of files included.  It sets the variable ATREE_FILES.\n"
../build/tools/atree/atree.cpp:285:            fprintf(f, "ATREE_FILES := $(ATREE_FILES) \\\n");
../build/core/Makefile:1178:ATREE_FILES :=
../build/core/Makefile:1182:ifeq ($(strip $(ATREE_FILES)),)
../build/core/Makefile:1183:ATREE_FILES := \
../build/core/Makefile:1210:	$(ATREE_FILES) \
../out/host/linux-x86/sdk/sdk_deps.mk:1:ATREE_FILES := $(ATREE_FILES) \


# makefile (¿?'build/core/Makefile'¿?¿? 1179)
ATREE_FILES :=  out/target/product/generic/system/usr/share/zoneinfo/zoneinfo.dat 
out/target/product/generic/system/usr/share/zoneinfo/zoneinfo.idx 
out/target/product/generic/system/usr/share/zoneinfo/zoneinfo.version 
out/target/product/generic/system/etc/security/cacerts.bks 
out/target/product/generic/system/usr/ke








frameworks/base/core/java/android/content/Intent.java      parseUri 


ANDROID_RESOURCES 

anim、array、attr、id、color、dimen、drawable、integer、layout、string


XLIFF: 全称 XML Localisation Interchange File Format, XML 本地化交换文件格式 

<resource xmlns:xliff="urn:aasis:names:tc:xliff:document:1.2">    
... 
  <string name="text_format"><xliff:g id="prefix"></xliff:g></string> 
... 
</resource> 

strings.xml 


切换系统本地化语言
Resources   resources = getResources();
Configure     config = resources.getConfiguration();
DisplayMetrics dm = resources.getDisplayMetrics();

config.locale = Locale.SIMPLIFIED_CHINESE;
resources.updateConfiguration(config, dm);


#setprop persist.sys.language zh;setprop persist.sys.country CN;stop;sleep
5;start
#echo zh-CN >/data/locale;stop;sleep 5;start

./libcore/xml/src/main/java/org/apache/xml/serializer/Encodings.properties


{@link #Favorite_y irdc.EX07_04:y}


问题小结
1. activity 启动失败
AndroidManifest.xml 里没有声明标记 activity

2. View layout 时 Widget 不全
比如，在 LinearLayout 里 TextView 和 Spinner 各放一个，结果只画出了一个。
原因是，LinearLayout 的属性 android:orientation 没有定义。

3. findViewById 获取资源失败
findViewById 一定要放在 setContentView 之后，否则获取的只是空指针。

4. CursorAdaptor 不起作用
传给 CursorAdapter 的 Cursor 结果集中必须包含有名为 "_id" 的列。

5. ContentProvider 中，单一数据的 MIME 类型 "vnd.android.cursor.item/"
数据集的 MIME 类型为 "vnd.android.cursor.dir/"
UriMatcher 的方法 addURI 中第二个参数的匹配路径 "#"代表？？？

6. 
   try{
                final String SERVERURL = "http://www.google.com";//"http://hq.sinajs.cn/list=sz000936";
                URL inquiryurl = new URL(SERVERURL);

                URLConnection conn = inquiryurl.openConnection();/*openConnection throw IOException*/
                Log.d(TAG, "step 1");
                conn.connect();
                Log.d(TAG, "step 2");
                InputStream is = conn.getInputStream();
                Log.d(TAG, "data is:"+is.toString());
                BufferedInputStream bis = new BufferedInputStream(is);

                bis.close();
                is.close();
                }catch(Exception e){
                    if (e instanceof MalformedURLException){
                    Log.d(TAG, "throw MalformedURLException!!!");
                    }
                    else if(e instanceof IOException){
                        Log.d(TAG, "throw IOException!!!");
                    }
                }
网络的问题 ， 代码放在 try块中，因为 URLConnection的方法 openConnection会抛出
IOException，而URL的构造函数会抛出MalformedURLException异常。
如果程序没有android.permission.INTERNET权限，IOException就会抛出。
D/SntpClient(   61): request time failed: java.net.SocketException: Address family not supported by protocol



还要其他的，比如动画中的 scaler、alpha，应用Launcher 的launcherProvider等不太常见的tag。可见，XML 无处不入。

getConfiguredNetworks

am start -n com.android.music/.StreamStarter -d /sdcard/music.wav

frameworks/base/tools/aapt/resource.cpp    isValidResourceType

TypedValue.java      coerceToString   @ ? 0x #

XML 中一些度量单位的含义：
px   ： rawpixel
dip   ：Device Independent Pixel
sp    ：Scale Pixel
pt    ：point
in    ：inches
mm   ：millimeters
In most cases, you can take advantage of density independence in your application simply by making sure that your layouts specify all dimension values in density-independent pixels (dip or dp) or scale-independent pixels (sip or sp, for text only). If you are using absolute pixel values in the application and manifest includes android:anyDensity="true", you will also need to scale the pixel values.

parse_unit      unitNames      解析表示计量单位的资源

TypedValue 是动态类型化数据值的容器，主要是用于 android.content.res.Resources 类中保持资源数值。

TypedArray 是Resources.Theme的方法obtainStyledAttributes(AttributeSet, int[], int, int) ，或Resources 的方法obtainAttributes 从资源中取出的一组数值的容器。
obtainStyledAttributes





sp<AaptDir> AaptDir::makeDir(const String8& path){
…..
while (name = remain.walkPath(&remain), remain != "") {
        subdir = subdir->makeDir(name);
}
……
}
红色部分的语法值得学习。虽然，在 Aapt中这段代码无关紧要。



只有在编译时检测到的属性才能在XML layout文件中设置。标签的值列表参见：
frameworks/base/core/res/res/values/public.xml
frameworks/base/api/*.xml



XMLNode.cpp 定义了几个常见的命名空间（NameSpace） 
XLIFF_XMLNS      RESOURCE_ROOT_NAMESPACE  

frameworks/base/core/jni/android_util_AssetManager.cpp:32:#include <utils/Asset.h> 

frameworks/base/libs/utils/Asset.cpp      _CompressedAsset::getBuffer   
  frameworks/base/include/utils/Asset.h      UNCOMPRESS_DATA_MAX 


ResXMLTree : public ResXMLParser
 

frameworks/base/core/jni/android_util_AssetManager.cpp 
AssetManager.h    AssetManager.cpp 


树形结构，树形解析
PackageParser.parseActivity  解析 activity 标记，并调用
PackageParser.parseIntent 解析 activity 标记下的 intent-filter

PreferenceInflater.onCreateCustomFromTag 调用 Intent.parseIntent 解析标记，
而 AliasActivity.parseAlias 也调用Intent.parseIntent 解析 intent 标记

PackageParser 里之所以不使用 Intent.parseIntent 解析 intent-filter
标签，是因为他希望解析结果以 ItentInfo 
对象保存，如ServiceIntentInfo、ActivityIntentInfo， 而 Intent.parseIntent
解析的结果是 Intent 对象。
但是有一点是相同的，即分层解析。
以 PackageParser 类为例：
一、解析第一层标记
类的初始化函数 public Package parsePackage(File, String, DisplayMetrics,
int) ，主要作了两件事：
1. 创建解析文件 AndroidManifest.xml 的解析器
    parser = assmgr.openXmlResourceParser(cookie, "AndroidManifest.xml");
2. 调用解析函数解析
    private Package parsePackage(Resources, XmlResourceParser, int, String[])
    这个函数解析的是 AndroidManifest.xml 中顶级标记 manifest
    下一层的所有标签，manifest 标记带有 package
    属性。比如，调用 parseApplication 对 application 标记解析; 调用
    parsePermission 解析标记 permission; 对标记 instrumentation
    使用方法 parseInstrumentation 分析。
二、解析第二层标记
以 parseApplication 为例，对application 标记下的子标记 activity，service，provider等分别调用
parseActivity，parseService，parseProvider 解析。

三、解析第三层
再以 parseActivity 为例，调用方法 parseIntent 和 parseMetaData 分别解析标记
intent-filter 与 meta-data。

四、解析叶子标记
所谓叶子标记是其下没有了子标记，节点标记其下有子标记，也就是标记容器。
对于叶子标记的解析方法就是
Resources.obtainAttributes。对于节点标记，除了要获取属性 (
Resources.obtainAttributes )，还有一个重要的功能，就是拉出下一个标记
(XmlPullParser.next)，如果拉出的标记深度 (XmlPullParser.getDepth)
大于容器标记深度，就解析，否则退出，这是一种递归算法，保证解析的标记都是同一个层次。

XmlPullParser
解析出来的是流，即按文件中出现的顺序解析节点，而不是节点的层次。采用层次处理解析的标记流，把不同层次的标记放在不同方法，同一个层次的都在一个方法，清晰而简洁。


例如： 
<TextView  android:id = "@idd/myTextView"     ... /> 

属性“android:id” 的值应该是引用 myTextView 的字符串，即"@id/myTextView"，这里对了一个"d"，写成了"idd"。构建资源时就报 “Error： No resource found that matches the given name (at "id" with value '@idd/myTextView')." ，此错误在函数 ResTable::StringToValue  (ResourceTypes.cpp) 报出，它是调用了 ResourceTable.cpp 的函数 reportError。 

frameworks/base/include/utils/ResourceTypes.h 的类 ResTable::Accessor 声明了纯虚成员函数reportError 
frameworks/base/tools/aapt/ResourceTable.h 的类 ResourceTable 继承 ResTable::Accessor， 
frameworks/base/libs/utils/ResourceTypes.cpp  实现了，Res_Value, 

static bool applyFileOverlay(Bundle *bundle,
                             const sp<AaptAssets>& assets,
                             sp<ResourceTypeSet> *baseSet,
                             const char *resType)

    // look for same flavor.  For a given file (strings.xml, for example)
                    // there may be a locale specific or other flavors - we want to match
                    // the same flavor.


ResourceTable.cpp  函数 compileAttribute、compileResourceFile、compileXmlFile 
compileResourceFile、parsePackage 等解析 XML 文件的函数都要调用
parseXMLResource 初始化 XML 解析。 因为 parseXMLResource 调用方法
XMLNode::parse， 后者正是调用 XML_Parser 解析器引擎。
XMLNode::parse 通过读取 XML
文件把标记保存到内存中，解析器的用户数据是一个 ParseState
类型结构体 （她是 XMLNode 类的私有结构体）变量，解析出来的数据保存在成员stack
（这是一个Vector对象，元素是sp<XMLNode>），结构体成员 root （sp<XMLNode>
类型）是指向 stack 中的第一个节点。 TODO：：
parseXMLResource   转化到 XMLNode 树形结构， 再到 AaptFile，最后到 ResXMLTree
结构。从XML 的树形-》 Expat 的流 -》 XMLNode 的树 -》 ResXMLTree

ResXMLTree 字面含义应该是个树形结构，其实是个流或者说数列，使用方法
ResXMLTree block;
status_t err = parseXMLResource(in, &block, false, true);

if (err != NO_ERROR) {
        return err;
    }
block.next();

block.getElementName(&len);    //获取标记的名字
size_t len;
ssize_t itemIdentIdx = block.indexOfAttribute(NULL, "name"); //获取属性名name的属性索引
if (itemIdentIdx >= 0) {
    // 通过索引获取属性值
    itemIdent = String16(block.getAttributeStringValue(itemIdentIdx, &len));
} 

ResXMLTree 是 ResXMLParser 的派生类，
ResXMLParser::next    -》 ResXMLParser::nextNode
ResXMLParser::indexOfAttribute ， 比较简单，遍历元素的所有属性即可。
ResXMLParser::getAttributeStringValue

Resource.cpp

makeFileResources    ResourceTable* table,   table->addEntry   .
                    Const sp<AaptAssets>& assets  assets->addResource 
因为知道，估计 addEntry 是构建 内存 XML 模型树，Assets 是加入到。Apk包中的文件。  
从此入手 ，搜索"addEntry"， compileResourceFile （）  ， generateAttributes

makeFileResources     把res目录下的子目录文件编译进来，  drawable， layout，anim，xml，raw 
buildResources 先对drawable，layout， anim， xml，raw，color， menu，
目录使用函数 makeFileResources; 再对 layout， anim， xml，raw, color,menu
使用compileXmlFile。 对values 目录下的文件使用compileResourceFile， 调用
 compileAttribute(R.java declare-style的属性的产生)

makeFileResources 是以文件作为资源单位编译，他使用 ResourceDirIterator
枚举指定目录下的文件，并对文件名作判断（文件名只能在[a-z0-9_.]中取值，所以大写字母是不行的），
然后， 调用 table->addEntry 把文件加入到 ResourceTable 的一个Entry中，
这个 Entry 的源位置是文件路径，行号为0, Package ， type 就是
makeFileResources 最后参数，即目录名就是类型名， name 是文件名， value
是路径（根据平台，会把"\" 转换为 "/"）。
注意到 makeFileResources 的最后参数，她不仅仅作为目录名给
ResourceDirIterator 枚举文件， 而且在table->addEntry 作为 Type。

再来，分析一下 ResourceTable::addEntry 函数。他实际上就是
ResourceTable::getEntry 包装， getEntry 会调用 ResourceTable::Package::getType
获取 Type，getType 查询 Package 的 mTypes 里有没有这个Type， 查询没有就建立一个。
然后，通过 ResourceTable::Type::getEntry 查询 Entry，
类似的，先查询，若无就new 一个 Entry。
回过头看，buildResources 开头的一条语句 
err = table.addIncludedResources(bundle, assets);
 ResourceTable::addIncludedResources 函数的最后面调用 ResourceTable::getType
 建立了 attr 类型，即 attr 类，这就是 R.java 的开头总是能看到内部类attr，即使是空的。  

compileXmlFile 是以文件为单位编译的，编译后还是一个文件，但不再是文本文件， 而是二进制文件， APK
资源的目录结构和源代码中的一样，即编译前后文件的相对路径（从 res
开始）没改变。 R.java 相对应的资源是
resources.arsc，这里当然有以文件为单位的资源索引，也有像 resources
标记下的各种资源。 

addResourcegetResourceFile 就是为了获取 resources.arsc。
（assets->getFiles().valueFor(String8("resources.arsc"));）因为 AaptAssets 继承
 AaptDir， getFiles 是后者实现的，也就是说在AaptAssets的根目录下找resources.arsc 
这个文件，没有的话就加入 resources.arsc 这个节点
（assets->addFile(String8("resources.arsc"), AaptGroupEntry(), String8(), NULL, String8());）
当然也是在根目录下， addFile 也是类 AaptDir的接口

AaptAssets.cpp
Resource.cpp makeFileResources
||/
AaptAssets::addResource
Type has an ConfigList , ConfigDescription
Entry has associated structure Item and SourcePos
SourcePos has only two member: filename, line number
For Id, which attribute name is “android:id”,  the finename is “<generated>”, and line number is 0.  
The following statement in function ResourceTable::Entry::generateAttributes tell us this information:
  status_t err = table->addEntry(SourcePos(String8("<generated>"), 0), package,
                                               id16, key, value);


ResourceTable::assignResourceIds
ResourceTable::Entry::assignResourceIds
ResourceTable::getResId
makeResId    ，     ResTable::identifierForName  （这个是关键！！）
ResourceTable::Package::getAssignedId
ResourceTable::Package:: mIncludedId 只在对象初始化时涉及到
搜索”new\s*Package”
ResourceTable::addIncludedResources 末端
ResourceTable::getPackage

ResourceTable::getPackage 跟 mNextPackageId 关系不大， mNextPackageId 为2
“*** NEW PACKAGE: "com.android.speechrecorder" id=127”
ResourceTable::mNextPackageId    与分配的Package ID 关系密切，ResourceTable::ResourceTable 构造函数把 此值初始化为1。  Package ID 的值一般只有两个 ：
1  →  android
127 → com.android.launcher     (AndroidManifest.xml 的 “manifest”标记的package属性值)

ResTable::identifierForName  打印分析，只负责了   0x7f01xxxx(class attr),  0x7f08xxxx(class id)， 0x7f0dxxxx (class  style)  以及 Android包中的内容。

uint32_t ResTable::getBasePackageId(size_t idx) const
{
    if (mError != NO_ERROR) {
        return 0;
    }
    LOG_FATAL_IF(idx >= mPackageGroups.size(),
                 "Requested package index %d past package count %d",
                 (int)idx, (int)mPackageGroups.size());
    return mPackageGroups[idx]->id;
}



AaptAssets.h   AaptAssets 
 AssetManager mIncludedAssets;



ResourceDirIterator 递归获取 values 目录中文件，使用 compileResourceFile
解析。

AaptAssets.cpp 函数 isHidden 根据文件名把一些特定的目录和文件排除掉。
AaptAssets::slurpResourceTree 及 AaptDir::slurpFullTree 用到。

AaptAssets::slurpResourceTree 只被 AaptAssets::slurpFromArgs 调用到。

Resource.cpp 中定义的函数 collect_files

AaptAssets     resDir 根据参数指定的目录名返回一个 AaptDir 智能指针,  resDirs() 返回的是一个列表，元素是 AaptDir 的智能指针

AaptGroupEntry 类似于 ResTable_config,  IMSI,
语言、屏幕大小、分辨率、尺寸规格、键盘等等，当然有版本号，不然版本升级时由于数据不兼容而产生严重的错误。
为此 AaptGroupEntry 提供了 compare
 来比较两个对象的大小，这个函数其实按一定顺序比较各个数据成员（这个顺序其实就是数据成员的优先级）。而这些数据成员都是String8
 类型的，String8 类也提供了 compare 方法，他也就是调用了strcmp，所以到底还是字符串比较。

AaptFile ： 说是文件，其实更恰当的是一个buffer，他不关心 buffer
数据的格式、含义，只管申请空间、读、写数据。buffer相关的数据成员，如mData
即指向buffer， mDataSize 标示 mData 里使用的空间，mBufferSize 是 mData
总的空间 （从这里看出代码命名的混乱）。
虽然对buffer里面内容不关心，但是在buffer整体标示，AaptFile
还是有相关的数据成员，如mGroupEntry 是 AaptGroupEntry，mResourceType （String8），以及
原来的文件名、路径和数据压缩算法等相关信息。


 AaptGroup ： A group of related files (the same file, with different vendor/locale variations).
 他的一个主要数据结构是 ：
 DefaultKeyedVector<AaptGroupEntry, sp<AaptFile> > mFiles; 
 从这里可见， AaptGroup 是一系列 AaptFile 的有序集合，这些 AaptFile 以
 AaptGroupEntry 的次序排列。为此 AaptGroupEntry 提供了 compare
 来比较两个对象的大小，这个函数其实按一定顺序比较各个数据成员（这个顺序其实就是数据成员的优先级）。
      
compileXmlFile 		
  status_t err = root->parseValues(assets, table);
   err = root->flatten(target,
            (options&XML_COMPILE_STRIP_COMMENTS) != 0,
            (options&XML_COMPILE_STRIP_RAW_VALUES) != 0);
            
    //设置文件的压缩算法
    target->setCompressionMethod(ZipEntry::kCompressDeflated);
        
    assignResourceIds    
    
    generateAttributes
    setIndex    setEntryIndex
     sp<Entry>::assignResourceIds     


compileResourceFile  从函数体开头部分字符串的定义可知，其解析 <resources/> 标签下的元素，
 1, Top-level tag :                     resources 
 2, Identifier declaration tags :       declare-styleable, attr
 3, Data creation organizational tags : string, drawable, color, bool,
 integer, dimen, fraction, style, plurals, array, string-array,
 integer-array, public-padding, private-symbols, add-resource, skip,
 eat-comment
 4, Data creation tags :       bag, item
 5, Attribute type constants : enum

 //下面两个不是tag，而是属性名和值
 6, plural values :            other, zero, one, two, few, many, 
 7,  useful attribute names and special values  name, translatable, false

compileResourceFile 函数比较庞大，有 800 多行， 但是结构还是简单的。
原理跟 PackageParser.java 解析 AndroidManifest.xml
一样，即把标记流按层处理，这也是流-拉模型的典型处理方法了。下面简单分析一下:
1, parseXMLResource,
这个函数比较简单，现在不清楚具体做什么，但可以肯定的是她调用 XML
解析器引擎初始化 ResXMLTree 结构。
2, 拉出 resources 标记
跳过所有的（命名空间）声明后，判断是否为标记，然后检查标记名
    if (strcmp16(block.getElementName(&len), resources16.string()) != 0) {
        ... ...
        return UNKNOWN_ERROR;
    }
    resources16 就是值为 "resources" 的常量对象。
3, 处理 resources 标记
   这个语句块的结构如下：
    while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
        if (code == ResXMLTree::START_TAG) {
            ... ...    // 处理tag语句块
        }
        else if (code == ResXMLTree::START_NAMESPACE || code == ResXMLTree::END_NAMESPACE) {
        }
        else if (code == ResXMLTree::TEXT) {
            if (isWhitespace(block.getText(&len))) {
                continue;
            }
            ... ...
            return UNKNOWN_ERROR;
        }
    }

处理 tag 语句块 基本结构就是 if-else if-else 的控制语句，判断条件就是 tag
名，tag处理一般形式如下：
   if (strcmp16(block.getElementName(&len), skip16.string()) == 0) {
                ... ... // 子标记解析语句块  
                while ((code=block.next()) != ResXMLTree::END_DOCUMENT
                        && code != ResXMLTree::BAD_DOCUMENT) {
                    if (code == ResXMLTree::END_TAG) {
                        if (strcmp16(block.getElementName(&len), skip16.string()) == 0) {
                            break;
                        }
                    }
                    else if (code == ResXMLTree::START_TAG) {
                        ... ... //子标记中的子标记处理语句
                    }
                }
                continue;

            } else if () {
                ......
            }

skip16、eat_comment16 最简单的形式，继续拉，直至标记结束， 没有 解析语句;
public16， public_padding16， private_symbols16，add_resource16，
有子标记解析语句块;
attr16 调用了 compileAttribute 处理。
declare_styleable16 标记处理比较麻烦，因为底下又子标记，
所以有子标记中的子标记处理语句，这些标记有
skip16， eat_comment16， attr16 。(addSymbol, appendComment)

item16，string16，drawable16，color16, bool16, integer16, dimen16,
fraction16 以及 bag16， style16， plurals16， array16， string_array16，
integer_array16
根据标记名仅仅作了少量处理，比如设置了一些变量名，然后放在后面统一处理。他们都有一个共通的特点，就是有"name"属性。
但自bag16后的标记，需要是个容器或者说袋子，里面还有 item16
标记要处理，与 declare_styleable16 ，处理大概流程就是上面的代码片断，完了调用 parseAndAddBag
。前面的其他标记处理就比较简单，调用 parseAndAddEntry 即可。

多语言：
string16 中可能与多语言相关的函数 translatable16, getAttributeStringValue,
getResourceSourceDirs。

属性：
上面的标记会有很多的属性，这些属性怎么来的呢？ 这些属性都是由
declare-styleable 声明的，Android 系统级的属性，
参见 SDK 文档
docs/reference/android/package-summary.html
docs/reference/android/R.id.html
或者编译后的文档
out/target/common/docs/offline-sdk/reference/android/package-summary.html
out/target/common/docs/offline-sdk/reference/android/R.id.html
应用中，我们一般把声明属性的 declare-styleable 标记放在文件
res/values/attrs.xml，而使用这些属性的 XML 文件不能与 attrs.xml
同目录，即不能放在 res/values，可以放在 res/xml, res/color, res/anim 等等，或者
res/drawable 也行？


R.java 里的注释
函数 compileAttribute、compileResourceFile, mayOrMust, 以及数组 gFormatFlags
均会给节点增加一点注释。 而 declare-styleable 声明属性时，生成的 attr、
styleable 内部类及相关的域，会有大量的注释，他们是有 writeLayoutClasses 搞的。
函数调用顺序（main -> doPackage -> writeResourceSymbols -> writeSymbolClass ->
writeLayoutClssses -> getAttributeComment)

parseStyledString

递归函数

 后者调用调用 compileAttribute (R.java declare-style的属性的产生)
解析文件中的各个标签。

     
     
Resource.cpp     
	parsePackage      AndroidManifest.xml
	
	postProcessImages    drawable 目录，   
        ResourceDirIterator    搜索一个目录下的文件
	
	ResourceTypeSet 资源类型
 


ResourceTypes.cpp   ResTable::stringToValue  对属性值作检测 如， 属性值开头的
'@', '#', '?', "true", "TRUE", "false", "FALSE"。

ResTable::collectString 对转义字符串以及上面提及的特殊字符会做处理。

buildResources
    // First, look for a package file to parse.  This is required to
    // be able to generate the resource information.
    主要是对 AndroidManifest.xml 解析，  parsePackage
    
   // --------------------------------------------------------------
    // First, gather all resource information.
    // --------------------------------------------------------------


    // --------------------------------------------------------------
    // Finally, we can now we can compile XML files, which may reference
    // resources.
    // --------------------------------------------------------------


   // --------------------------------------------------------------
    // Generate the final resource table.
    // Re-flatten because we may have added new resource IDs
    // --------------------------------------------------------------

输出：
	writeResourceSymbols  生成文件 R.java 及 Manifest.java，
这两个文件中的头部声明"/* AUTO-GENERATED FILE.  DO NOT MODIFY. ..."
就是由这个函数打印的，
但是她仅仅是合成文件名和路径，打印头部声明，真正干活还要靠
writeSymbolClass ，即 writeResourceSymbols 调用了 writeSymbolClass，
这两个函数均在 Resource.cpp 实现。
	writeResourceSymbols  生成文件 R.java 及 Manifest.java，

因为可以看到	AUTO-GENERATED FILE.  DO NOT MODIFY.  头部内容

writeSymbolClass 是干活。

writeAPK（Package.cpp），生成.apk， APK的文件名由getOutputAPKFile获取
TODO：：可以比较 writeAPK 与 writeSymbolClass 的异同啊！！！


writePublicDefinitions
-P  选项（不是-p[ackage]）   指定的文件，  
<public type="string" name="group_applications" id="0x7f0c000f" />

-G out/target/common/obj/APPS/Launcher2_intermediates/proguard_options

doRemove Command.cpp
Bundle 是保存 aapt 命令行信息。
bundle->getFileSpecCount 命令行中包含的文件数，第一个文件名应该是压缩文件名
const char* fileName = bundle->getFileSpecEntry(i);
通过下标获取命令行中的文件名。

ZipFile* zip = openReadWrite(zipFileName, false);
这个是打开 apk 压缩文件，apk 采用的压缩格式其实就是Zip算法。

  ZipEntry* entry = zip->getEntryByName(fileName);
ZipEntry 就是压缩文件的单位文件的数据结构。

zip->remove(entry);                                        //删除



zip->add(fileName, bundle->getCompressionMethod(), NULL);   //增加

zip->addGzip     //增加 .gz 文件

 zip->flush();

 delete zip;


ant : 打包 apk 文件
acp : 类似 cp 的文件拷贝工具， Android cp。
atree: 把多个不同目录下的文件树，有组织的拷贝到一个目录下。
aapt: Android Asset Packaging Tool，创建、查看、更新 zip 格式兼容的文档（.zip, .jar, .apk），例如，把资源文件编译成二进制资源包， 并生成R.java 和 Manifest.java。
dx:  把 Java 字节码转换为 Dalvik 可执行的字节码，即把.class 文件转换为 .dex （Dalvik EXecuteable format）文件
zipalign

>I'm working on the Froyo codebase and trying to enable the dexpreopt
> in build system. However, I am curious what the benefits of enabling
> dexpreopt. It seems to me that that will definitely improve the first
> time boot up speed. Will it improve the speed of second boot? Will it
> improve the performance of the apk?
>

WITH_DEXPREOPT=true 
Make sure DISABLE_DEXPREOPT is not defined in your environment.
(Note that DISABLE_DEXPREOPT is defined in build/envsetup.sh). 
-it reduces the overall flash usage by stripping the original dex data
from the apks.

-most importantly, it guarantees that system upgrades will install
regardless of how full the data partition is (without that, it's
possible for a system upgrade to make a device unbootable unless doing
a factory reset).

prebuild






Actually bionic is not a part of Android Linux Kernel, but a replacement of
glic which is used in normal Linux.
The differences between Android Kernel and mainstream kernel are:
1. binder: used for IPC
2. Ashmem: Anonymous shared memory, used for inter-process communication
3. pmem: used for shared memory as well
4. power management: introduce wake lock into PM, which is more aggressive
5. logger: made a new logger for Android debug info output
6. yaffs2: integrated yaffs2 filesystem into Kernel which is not in
mainstream kernel
7.framebuffer: Android needs dual-buffer 

SystemServer.FACTORY_TEST_OFF)

每启动一个新的应用或者Service， ActivityManangerService都将为该进程创建一个ApplicationThread客户端，当有其他应用需要创建新的 Activity或者Bind Service时，system service 就会通过binder IPC 机制通知到相应的application。一旦Application在ActivityManangerService中创建了客户端，则客户端与客户端，客户端与Server的IPC连接都建立 了，在Binder IPC通信中已经说了，对于需要IPC通信的两个不同进程，只要获得了对方在Binder Kernel中建立的Binder参考，就可以互相传递数据 了。应用由system service进程启动，具体过程可以参考下面的示意图，这里就不贴源码分析了。

The trick was that you have to use port 29418, not 22, when
connecting.

There are sshd:s running on both ports, but only the one on port 29418
allows
Gerrit users to login.


If you are talking about *android* applications, the decision to start and end them doesn't happen in Dalvik.  ActivityManagerService is the one that decides when to start *processes* (not that "application" is a concept is extremely fuzzy on Android), and usually it is the out of memory killer that decides when they go away through a brutal SIGKILL to the process (though sometimes ActivityManagerService will do this itself). 

So if you want to keep track of apps, you will need to work in those constraints.  And this includes the fact that *nothing* inside of the process knows when that process is going away or has any chance to run at that point; in fact nothing in *user-space* typically does. 

Now, again, what we are talking about is *processes* which is really not the same as an application.  A process on Android is just a container in which to run some code; it is not directly tied to an application as perceived by the user.  For example, when the user "launches" the contacts app, often it is actually just loading and running code in a process called "acore" that also runs many other things (in some devices Launcher, search services, etc) and thus has no relation to the time spent in the "contacts" app. 





Just follow the code from ContextImpl.startActivity() -> ActivityMangerService.startActivity; in ActivityManagerService there is a bunch of work to maintain the activity stack and keep the top activity in the stack resumed as described by the activity lifecycle documentation in the SDK.  This is done by performing calls on IApplicationThread, which is implemented by ActivityThread to receive commands from the activity manager and execute them.


ActivityManagerNative is not really interesting.  It is just the marshalling side of the IPC interface with the activity manager.


I would strongly recommend when exploring the code to load it up in to Eclipse.  Being able to use Command-G (to find implementations of a symbol) and Shift-Command-G (to find references to a symbol) make it a lot easier to follow calls across the code.


Activity 和 Application

一般接触了 Android 就知道， 我们要在 AndroidManifest.xml
定义activity标记，并且其 android:name 的属性值是 Java
代码中要实现的类名，这个类是 Activity 派生类。 其实，application
标记也是可以设置 android:name 属性的，如果设了，则类似 activity，必须在 Java
代码里实现一个 Application 类，类名就是这个属性的值。不过一般 application
标记不设 android:name 属性， 也就是一般我们是了 Android Framworks 中的
Application 类; 而 activity 标记，恰恰相反，一般都设置属性
android:name，实现 Activity 的派生类。 这个不难理解，我们需要修改默认类的行为，就在 AndroidManifest.xml
定义 android:name，并在代码里实现。 Launcher 的 AndroidManifest.xml 就设置了
application 的 android:name 属性。

Context
是处理应用程序环境全局信息的接口，用它可以访问应用相关的资源和类，以及
调用应用级操作，如投放 activities， broadcasting， receiving intents ，等等。

Activity
Context.startActivity
Activity.startActivityForResult
Activity.setResult

Context.registerReceiver
Context.unregisterReceiver

Context.startService
Context.bindService
Context.stopService
Context.unbindService

Context.sendBroadcast
Context.sendOrderedBroadcast
Context.sendStickyBroadcast

registerDefaultProviders


AndroidManifest.xml 的 package 必须和 Java 代码里的 package 一致。

控制反转 (IoC)就是Inversion of Control。在Java开发中，IoC意味着将你设计好的类交给系统去控制，而不是在你的类内部控制。这称为控制反转。
不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器负责将这些联系在一起。其原理是基于OO设计原则的The Hollywood Principle：Don't call us,we'll call you（别找我，我会来找你的）。也就是说，所有的组件都是被动的（Passive），所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：控制权由应用代码中转到了外部容器，控制权的转移，这就是反转。



<?xml version="1.0" encoding="utf-8"?>
  <manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="irdc.ex03_10"
      android:versionCode="1"
      android:versionName="1.0.0">
    <application android:icon="@drawable/icon" android:label="@string/app_name">
      <activity android:name=".EX03_10"
                android:label="@string/app_name">
        <intent-filter>
          <action android:name="android.intent.action.MAIN" />
          <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
      </activity>
      <activity android:name="EX03_10_1"></activity>
    </application>
  </manifest> 


libhardware/modules/gralloc/framebuffer.cpp
/hardware/libhardware/modules/gralloc/framebuffer.cpp

unlockCanvas
/dev/fb0, /dev/graphics/fb0
FBIOGET_FSCREENINFO , FBIOGET_VSCREENINFO
.fb_pan_display
http://www.netmite.com/android/mydroid/development/pdk/docs/display_drivers.html

  //change to landscape mode
 
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);

//To change to portrait mode
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);

Or You can also used directly in manifest file inside activity as
 android:screenOrientation="landscape"


I found out the problem was in Avrcp.kl , Its file my system is using for scancode -keycode generation.
I added following in avrcp.kl after i found that 164,128 and 159  has no entry at all:

key 164   MEDIA_PLAY_PAUSE    WAKE
key 128   MEDIA_STOP          WAKE
key 159   MEDIA_FAST_FORWARD  WAKE

Launcher2 分析
拖动效果处理
DragView 是对象被拖动时的表示。DragSource 是可被拖动的对象，比如
BubbleTextView


DragScroller 是个接口，被 Workspace 实现，当拖到边界时，滚动到下一个
Workspace。 SymmetricalLinearTween
是当一个被拖动按住一定时间后， 变成可以拖动时的动画效果。




把图标拖到垃圾箱上的处理流程
DragController 方法 onTouchEvent 响应拖动事件
MotionEvent.ACTION_MOVE， 拖动目标(DragView)移到接受对象时调用
dropTarget.onDragEnter， 移出接受对象时调用 mLastDropTarget.onDragExit。

垃圾箱（deletezone）就是一个 drop target，在 DeleteZone 类实现了接口
DropTarget，以及 DragController.DragListener。 其 onDragEnter 方法把 
DragView 的画笔设为mTrashPaint，而mTrashPaint 在 DeleteZone(Context,
AttributeSet, int) 中已设置过滤色红色; 而 onDragExit 仅仅是把 DragView
的画笔设回 null。 

Launcher 中有许多类作了派生，这些类在一般的应用中都不去修改这些类的行为。
比如，LauncherApplication 是 Application 的派生类，为此在 AndroidManifest.xml 把
application 标签的属性 android:name 设置为 "com.android.launcher2.LauncherApplication"。
DragLayer 是 FrameLayout 的派生类，Workspace 是 ViewGroup 的派生类，所以在
res/layout-land/launcher.xml, res/layout-port/launcher.xml 中
com.android.launcher2.DragLayer 作为了根标记名， com.android.launcher2.Workspace
作为一个标记名。
com.android.launcher2.ClippedImageView 、com.android.launcher2.DeleteZone、 com.android.launcher2.HandleView

launcher.xml 看桌面的layout
FrameLayout 的布局是把其中的 View
都往屏的某个区域绘制，这个区域的大小由其包含的 View 中占面积最大的 View
（不管这个 View 是否可见）决定，View
压栈方式绘制，即先加入的先绘制，最后加入的绘制在最上层。

workspace （Workspace），previous_screen、next_screen （ImageView，横屏时ClippedImageView），
delete_zone （）， all_apps_button_cluster （RelativeLayout）
workspace 占了除状态栏之外的空间，容纳各种图标。previous_screen、next_screen
分别位于左下角和右下角，切换工作空间。 delete_zone
位于底下居中的位置，用于删除图标的，默认是不可见的。 all_apps_button_cluster
与 delete_zone 位置相同，又由3个子 View 组成， all_apps_button
（com.android.launcher2.HandleView 对象）可以列出应用程序，
hotseat_left（ImageView）可以启动电话应用，hotseat_right（ImageView） 可以进入浏览器。

src/com/android/launcher2/Workspace.java
初始化确定默认的 workspace
  TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Workspace, defStyle, 0);
        mDefaultScreen = a.getInt(R.styleable.Workspace_defaultScreen, 1);
        a.recycle();

更换 workspace 调用函数snapToScreen
scrollLeft、scrollRight，是对其包装，previousScreen和
nextScreen分别调用了 scrollLeft 和 scrollRight

ClippedImageView 横屏时使用，竖屏时使用 ImageView

UserFolder, FolderIcon, Folder, LiveFolderIcon, DeleteZone, Workspace, AllApps2D, AllApps3D,
实现了 DragSource，这些对象可以发起拖动。

Workspace、DeleteZone、FolderIcon、LiveFolderIcon、UserFolder
实现了 DragTarget，这些对象可以接受拖动，也就是对拖动的动作会作出响应。

LauncherAppWidgetHostView 占据一个屏幕， Google 搜索条，机器人（2.2
上才有）、时钟等
BubbleTextView 是桌面快捷图标对象，占据一个网格。

frameworks/base/core/java/com/android/internal/appwidget   定义了 AppWidget
的AIDL

 EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                SystemClock.uptimeMillis());
(ZygoteInit.java)

res/values/sytles.xml 名为 WorkspaceIcon style，其 background 引用
res/drawable/shortcut-selector.xml

state_pressed 为true时使用图片 res/drawable/pressed_application_background.9.png
作为 icon 的背景。

state_focused 为true时，state_window_focused 为 true
时，使用图片 res/drawable-mdpi/focused_application_background.9.png 或
             res/drawable-hdpi/focused_application_background.9.png 
如果 state_window_focused 为 false，使用的是颜色 android:color/transparent,
这个颜色值在 frameworks/base/core/res/res/values/color.xml

AllApps
AllApp2D   id/all_apps_view
  GridView  id/all_app_2d_grid
  AllApps2D::HomeButton id/all_apps_2d_home

  mAllAppsGrid = (AllAppsView) dragLayer.findViewById(R.all_apps_view);

  res/xml/default_workspace.xml  是默认的 workspace 布局

Launcher.onLongClick
长点击事件处理，流程是：
1. 根据 View 的 ID 判断被点中的 View
是否是底下的三个图标，即相左切换 Workspace 按钮、向右切换 Workspace
按钮、以及程序列表入口图标。
2. 判断 Workspace 是否锁住了，锁住了返回，结束处理。否则，从 CellLayout
对象获取 CellLayout.CellInfo。
3. 如果是长按在一个空白的地方， showDialog(cellInfo)，让用户添加项目到
  Home，如果长按的是一个项目 （不是文件夹），则
  mWorkspace.startDrag(cellInfo) 开始拖动。 对于文件夹 (folder)， 长按键在
  Folder.onLongClick 处理，


WallpaperChooser.java
Live Wallpaper 与一般的 Service 很类似，唯一不同的是他有个方法
onCreateEngine， 这是用来创建 WallpaperService.Engine

frameworks/base/services/java/com/android/server/WallpaperManagerService.java
frameworks/base/core/java/com/android/internal/service/wallpaper/ImageWallpaper.java
默认的内置墙纸，就是简单得显示静态图片。
frameworks/base/core/java/android/app/WallpaperInfo.java
frameworks/base/core/java/android/app/WallpaperManager.java
frameworks/base/core/java/android/service/wallpaper/WallpaperService.java
frameworks/base/core/java/android/service/wallpaper/WallpaperSettingsActivity.java
WallpaperManager.setWallpaper

  3D Livepaper  多点触控

  packages/wallpapers/Basic/Android.mk
  packages/wallpapers/Basic/res/raw/galazy.rs

  RenderScriptScene.java  派生类 grass/GrassRS.java,  fall/FallRS.java
  frameworks/base/libs/rs/java/Fountain.java, Film.java
  system/core/libcc Almost C Compile,  OTCS obfuscated tiny C compile
  android.renderscript.RSSurfaceView
  android.renderscript.RenderScript

跑马灯
android:singleLine="true"
android:ellipsize="marquee"

android:addstatesFromChildren="true"
android:focusable="true"


Bitmap (位图)的方法：   createBitmap
Canvas (画布) 类方法 drawPoint（画点），
                     drawLine（画线）， 
                     drawCircle（画圆），
                     drawOval（椭圆），
                     drawRect（矩形区域）、 
                     drawPath（路径）
                     drawPicture
                     drawBitmap
                     drawText
                     clipRect 设置剪裁区域
                     setViewport 为图形输出设置当前视口
                     setBitmap   设置画布执行绘制的位图
                     setMatrix   设置矩阵
                     skew 倾斜
                     rotate 旋转

Paint (画笔)   getShader， setShader

Shape ：  ArchShape,   OvalShape,   PathShape,   RectShape,  RoundRectShape(四角为弧形的矩形)
Shader :包括 BitmapShader, ComposeShader,    渐变色
MaskFilter ：包括 BlurMaskFilter, EmbossMaskFilter,   TableMaskFilter

LayoutInflater  方法 from 通过 getSystemService 获取上下文(Content)中的 LayoutInflator 的实例。
方法 inflate 把 xml 表述的layout实例化成相应的View 对象。
Window （Window 是抽象类，PhoneWindow和MidWindow 是其实现） 中 方法
  public void setContentView(int layoutResID) 中的 就是通过 LayoutInflater.inflate 实现。
 有点像View 类findViewById 


AnimationListener 在 Animation.java 中定义的接口，用于接受动画开始、 结束、 重复等通知。
ViewGroup.java 方法 setLayoutAnimationListener 设置域 mAnimationListener
的值，亦即动画接口。 在方法 dispatchDraw 中使用此接口的 onAnimationStart
方法。而 ViewGroup 及 View 都实现了 AnimationListener 中的方法
onAnimationStart 和 onAnimationEnd, 但没有 onAnimationRepeat。 View 中的方法
setAnimation、 getAnimation、 clearAnimation 以及 startAnimation
等方法均与动画有关。



android.content.ServiceConnection
android.app.Service
android.content.Context.bindService();

/home/leo/android/platform/development/samples/ApiDemos/src/com/example/android/apis/app
RemoteService.java  
RemoteService.Controller
startService(new Intent("com.example.android.apis.app.REMOTE_SERVICE"));
stopService(new Intent("com.example.android.apis.app.REMOTE_SERVICE"));

LocalService.java 

LocalServiceActivities.java
LocalServiceActivities.Controller
   startService(new Intent(Controller.this, LocalService.class));
   stopService(new Intent(Controller.this, LocalService.class));


startService/stopService 是启动、停止服务;
bindService/unbindService 是与服务建立连接，断开连接。
相比服务启动、停止，与服务的连接更显复杂，涉及到 IPC 的问题，如AIDL， IBinder。 

客户端在绑定服务时， 要创建 ServiceConnection 对象，重写 onServiceConnected，
onServiceDisconnected 方法， 在 onServiceConnected 方法里获取服务对象，在
onServiceDisconnected 里释放服务对象。



服务连接的大概流程是：客户端发起绑定（bindService）， 系统查询服务，相应服务端 onBind 响应之，
系统在得到服务端响应后，再向客户端发送 ServiceConnection.onServiceConnected 消息。

服务端会在重写 onBind 返回 IBinder 对象，即服务对象。
对于本地服务，一般有一个域，它是一个 Binder 扩展类的对象，这个域在 onBind
中告诉给客户端。
而对于远程服务，也大致类似，但它是 AIDL 定义接口的内部类 Stub 的对象。
所以，对于本地服务，要实现一个Binder 扩展类，而对于远程服务的话，要 实现 AIDL
接口的内部类 Stub （ 如 IRemoteService.Stub ），是否是 IBinder 扩展。

本地服务和远程服务，在 onServiceConnected 有差别， 即获取服务对象有差别 
mService = IRemoteService.Stub.asInterface(service);//远程服务获取
mBoundService = ((LocalService.LocalBinder)service).getService();  //本地服务

在建立了连接之后，客户端就可以使用服务了。  unbindService
,就可以停止与服务端的连接了。

再从 AIDL 接口本身说来，服务端就是把接口的各个方法实现， 这些方法在其内部类
Stub 里定义，所以就是实现一个 Stub 的类。
而客户端就是使用 AIDL 接口。
当然，客户端和服务端有一个建立连接的过程。 服务端要做的是建立一个对象，重写 onBinder
传递对象， 客户端bindService, unbindService 以及管理连接的一个 ServiceConnection 对象


IPC 的回调机制：
如果 IDL 接口在客户端实现，那么这就是回调了。这个其实就是一个反向的通讯，一般
IPC 是客户端调用服务端，而反向 IPC 是服务端调用客户端方法。
Binding 是 RemoteService 的客户端，其实现一个回调接口。
 private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() {
     ...
 }
当然，凡是回调都要注册，这样才能与对方建立通讯。 撤销注册。

IRemoteService.aidl 接口中定义了两个方法
 void registerCallback();
 void unregisterCallback();

public interface IRemoteService extends android.os.IInterface{
    /** Local-side IPC implementation stub class. */
        public static abstract class Stub extends android.os.Binder implements com.example.android.apis.app.IRemoteService {
            private static class Proxy implements com.example.android.apis.app.IRemoteService {
               public static com.example.android.apis.app.IRemoteService asInterface(android.os.IBinder obj)
              {

               
               ... ... 
                 public void registerCallback() throws android.os.RemoteException {
                 ... ...}
                 public void unregisterCallback() throws android.os.RemoteException {
                     ... ... }
            }
        }

   public void registerCallback() throws android.os.RemoteException;  
   public void unregisterCallback() throws android.os.RemoteException;  
}
之所以，扩展静态内部类 Stub， 是因为 IRemoteService （即AIDL 定义的接口）
是接口，我们不宜直接扩展值。 而 Stub 是 IRemoteService 的实现抽象类，
IRemoteService 接口定义了方法 Stub 当然继承了，但 Stub
没有实现接口中定义的方法（所以Stub干脆定义成了抽象类），这些方法必须由服务器端实现。  
而相反，IRemoteService.Stub.Proxy 同样也是 IRemoteService
的实现类，她是可以实例化的静态类，而且实现了 IRemoteService
的所有方法。实际上，Proxy就是客户端的标准实现，客户端调用接口的方法就是调用Proxy中的实现。
因为 IRemoteService.Stub 方法 asInterface 实际上返回的是
IRemoteService.Stub.Proxy 对象，虽然写的是 IRemoteService
接口（对用户隐藏具体实现）。

注意到 IRemoteService.Stub 是 Binder 的派生类，  而 IRemoteService.Stub.Proxy
各个方法实现使用 IBinder （mRemote）方法 transact 传递 Parcel
类型数据（所以，各个方法的参数都会包装成 Parcel 类型数据，也就是这些参数必须是
Parcelable）。 而 IRemoteService.Stub.onTransact 就是响应 IBinder.transact，
所以，IRemoteService.Stub 与 IRemoteService.Stub.Proxy 中 IRemoteService
接口的各个方法是通过 IBinder 的 transact / onTransact 对接的。


   public int onStartCommand(Intent intent, int flags, int startId) {        
        // We want this service to continue running until it is explicitly
        // stopped, so return sticky.
        return START_STICKY;
    }
sticky 就是滴答的意思吧！


frameworks/base/core/java/android/content/pm/PackageManager.java
installPackage

Context getSystemService   可以获取的服务有   POWER_SERVICE, WINDOW_SERVICE, 
                                 UI_MODE_SERVICE, ACCOUNT_SERVICE, ACTIVITY_SERVICE, 
                                           ALARM_SERVICE, SEARCH_SERVICE,NOTIFICATION_SERVICE
                                           STORAGE_SERVICE...
ActivityManager里面可以获取到当前运行的所有活动，这是任务管理器的核心。
ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);  
ComponentName cn = am.getRunningTasks(1).get(0).topActivity;  

仔细看getRunningTasks的文档，里面说获取的是系统中"running"的所有task，"running"状态包括已经被系统冻结的task。而且返回的这个列表是按照顺序排列的，也就是说第一个肯定比第二个后运行。getRunningTasks有个整型参数，表示返回列表的最大个数。那么，我们如果把1作为参数给进去，那么他返回的task就是当前运行的那个task，然后从task中获取到最顶层的activity，这个activity就是当前显示给用户的那个activity了。
类似的，ServiceManager 可以管理系统中运行的所有服务 

startService， stopService，  startActivity， stopActivity --- Context 提供。

MountService监听是否有SD卡安装及移除，
ClipboardService提供剪切板功能，
PackageManagerService提供软件包的安装移除及查看等等，应用程序可以通过系统提供的Manager接口来访问这些Service提供的数据
WindowManager
SystemContextManager
SensorService
PowerManager
PackageManager
ContextManager
BatteryManager
AlarmManager， AudioManager
ActivityManager
以android系统支持sensor（传感器）实例来说明框架层的service和manager是如何配合工作的

1)         什么是sensor
sensor是传感器, 比如控制横竖屏切换利用的就是重力传感器(gsensor), 还有accelerator sensor可取得x, y, z三个轴上的加速度(应用如平衡球, 小猴吃香蕉等)

2)         应用程序调用（以下为关键代码）
sensorManager=(SensorManager)getSystemService(context.SENSOR_SERVICE);
lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
sensorManager.registerListener(sensorListener, lightSensor, SensorManager.SENSOR_DELAY_NORMAL);

3)         Manager层

a)          提供给应用程序调用的接口，同实与Service交互，实现功能
frameworks/base/core/java/android/hardware/SensorManager.java

4)         Service层

a)          开机时就运行的管理Sensor的后台服务
frameworks/base/services/java/com/android/server/SensorService.java

b)         snesor后台服务需要的JNI，通过它与系统级交互
frameworks/base/services/jni/com_android_server_SensorService.cpp

5)         系统层

a)          传感器的头文件，硬件提供商按此文件的定义实现其功能
hardware/libhardware/include/hardware/sensors.h

b)         传感器的系统层实现，与内核交互，此处通常是硬件提供商提供的
hareware/libsensors

6)         内核及硬件层
内核访问硬件，同时以设备文件等方式提供给上层控制接口和传感器数据

3.     系统层实现
1)         frameworks/base/core/java/android/*Manager.java     对应用的接口
2)         frameworks/base/core/jni/                                                     对应用的接口的JNI
3)         frameworks/base/services/java/com/android/server/    后台服务
4)         frameworks/base/services/jni/                                                        JNI与系统层接口
5)         hardware/libhardware/include/                                              系统层头文件
6)         hardware/libxxx                                                                     系统库支持
7)         内核支持

4.     应用程序如何使用
1)         查看系统提供哪些服务
find frameworks/base/core/java/android/ -name *Manager.java
此处可以看到调用系统提供服务的入口
2)         一般register listener，事件发生时都收到回调

5.    新建一个service（以froyo为例）

1)         接口：接口供应用调用
frameworks/base/core/java/android/app/ContextImpl.java  加服务名与Manager对应
frameworks/base/core/java/android/content/Context.java    加服务名定义

2)         Manager：提供服务对应的调用接口
frameworks/base/core/java/android/app/StartXXXXManager.java        实现调用接口
frameworks/base/core/java/android/app/IXXXXManager.aidl      定义调用接口
frameworks/base/Android.mk         加入aidl的编译

3)         service：提供后台服务支持
frameworks/base/services/java/com/android/server/XXXXService.java 服务实现
frameworks/base/services/java/com/android/server/SystemServer.java   启动服务

--------------------------------------------------------------------------------------


Parcel  方法很多，按操作分类，可以分成读（read），写（write），创建（create）。按数据结构
Primitives，primitive Arrays; 按数据类型可以分 Byte， Double， Float, Int，
Long， String等。
Primitives
writeByte, writeDouble, writeFloat, writeInt, writeLong, writeString
readByte,   readDouble, readFloat,  readInt,  readLong,  readString
用来读写基本数据类型，其他大多数数据操作都是基于这些函数。

Primitive Arrays
writeByteArray, writeDoubleArray, writeFloatArray, writeIntArray,
writeLongArray, writeStringArray, writeBooleanArray, writeSparseBooleanArray

readByteArray, readDoubleArray, readFloatArray, readIntArray,
readLongArray, readStringArray, readBooleanArray, readSparseBooleanArray

createByteArray, createDoubleArray, createFloatArray, createIntArray,
createLongArray, createStringArray, createBooleanArray, createSparseBooleanArray

Parcelables
writeParcelable， writeParcleableArray， writeTypedArray, writeTypedList
readParcelable，  readParcleableArray，  readTypedArray,  readTypedList

Bundles
writeBundle(Bundle), readBundle(),  readBundle(ClassLoader).

Active Objects
writeStrongBinder, writeStrongInterface, writeBinderArray,
writeBinderList,writeFileDescriptor
readStrongBinder, readBinderArray, readBinderList, readFileDescriptor
createBinderArray, CreateBinderArrayList

Untyped Containers
writeArray, writeList,  writeMap, writeSparseArray
readArray,  readList,   readMap,  readSparseArray, readArrayList

frameworks/base/libs/binder/Parcel.cpp


Bundle  表示 String 到 Parcelable types 的映射。表示一条可执行命令，常用于在其他的线程执行的代码


Binder
frameworks/base/libs/binder/IInterface.cpp,
frameworks/base/core/jni/android_util_Binder.cpp, android_util_Binder.h, 
内核代码放在目录 drivers/misc/binder.c
include/linux/binder.h

frameworks/base/libs/binder
frameworks/base/include/binder
frameworks/base/include/private/binder
frameworks/base/core/jni/android_util_Binder.cpp
frameworks/base/core/jni/android_util_Binder.h
frameworks/base/cmds/servicemanager/binder.h
frameworks/base/cmds/servicemanager/binder.c

AIDL 类均是 Parcelable 的实现 (implements Parcelable), 这一点在 Google I/O
文档中已经明确指出了的。Parcel 类是被 final 修饰，不可继承; 而 Parcel 是与
IBinder 配合，用来在进程间发送消息的(IPC)。 AIDL 是为了 IPC 存在的。

实现 Parcleable 接口的类必须有个名为 CREATOR 的静态域，CREATOR 是一个实现
Parcelable.Creator 接口的对象。

应用的 4 个组件
Activity  用户界面，用户交互活动。
Service   后台服务
BroadcastReceiver    接受/响应全局的事件
ContentProvider      允许应用程序访问（读写、创建）某个数据库




当 ContentReslover 产生一个请求时，请求指向的目标 ContentProvider 就会被激活，
其他三个组件 (activities, services, broadcast receivers) 会被异步消息 intents
激活。 对于 activities 和 services， intents 命名了正被请求的 action，
并指定了要运行的数据的 URI。 对于 broadcast receivers， Intent
对象命名了要广播的 action。

Intent 是一堆相关的信息集合，包括接受Intent的组件关心的信息，如执行的action，
有效的数据， 以及 系统相关的信息，如类别和指令。
一个Intent对象显示指定一个目标组件，对显式 Intent 指定的对象，
Android会找到该组件（AndroidManifest.xml 文件声明的 Activities、Services）
假如一个目标组件没有显式指定name，Android必须定位最佳的组件响应这个Intent。
Android 通过比较 Intent 对象和潜在目标的 Intent-filter
来达到此目的。所以 IntentFilter 是隐式Intent。在
AndroidManifest.xml中一个组件（ Activities，Services，
BroadcastReceiver ）可以包含任意个IntentFilter
（即intent-filter标记），如果组件没有定义IntentFilter，它可以通过显式Intent对象激活。

在代码里创建和注册的 BroadcastReceiver ， 
以IntentFilter对象直接实例化
AndroidManifest.xml intent-filter 标记

AndroidManifest.xml <intent-filter ../>
context.registerReceiver(); 仅适合 BroadcastReceiver, 直接创建了 IntentFilter
new Intent();


Intent 如果没有 action， 她不会被激活; 另一方面，如果一个 Intent 对象没有指定
action， 她就能匹配任意的 intent-filter。 同理， 如果 Intent 对象没有指定
category， 那么默认匹配 Intent-filter 的 category， 除非当她们传给
startActivity 时， 所有的隐式 Intent 中已有 CATEGORY_DEFAULT 的
Intent。所以要接受隐式 Intent 的 Activity 必须包括 CATEGORY_DEFAULT ， 但对
"android.intent.action.MAIN", "android.intent.action.LAUNCHER" 例外。


显式 Intent
onClick (View v) {
    ...
    startActivityForResult(new Intent(v.getContext(), RefreshJobs.clss),
                        0);
    ...
}


隐式 Intent
Intent myIntent = new Intent( Intent.ACTION_PICK,
                              Uri.parse("content://contacts/people"));
startActivity(myIntent);


<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="helloworld.sxboeye" android:versionCode="1" android:versionName="1.0">
    <application android:icon="@drawable/icon" android:label="@string/app_name">
        <activity android:name=".HelloWorld" android:label="@string/mainactivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name =".ListDemo" android:label="@string/listdemo">
            <intent-filter>
                <action android:name="android.intent.action.CREATE_LIST" />
            </intent-filter>
        </activity>
    </application>
</manifest>

       Intent list = new Intent("android.intent.action.CREATE_LIST");
        list.setClassName("helloworld.sxboeye", "helloworld.sxboeye.ListDemo");
        startActivity(list);
        return true;



一个 intent-filter 至少有一个 action

component name 相关的方法 setComponent, getComponent, 
Action 相关的方法setAction, getAction
Category 相关的方法 addCategory， removeCategory， getCategories
Data   相关的方法 setData， getData （Uri）， setType, getType (MIME,String)，
                 setDataAndType （适用于 URI 和 MIME）

setClass, setClassName


标准意图的活动动作（Standard intent activity actions）
Intent.ACTION_EDIT
Intent.ACTION_MANI
Intent.ACTION_VIEW
Intent.ACTION_SYNC
Intent.ACTION_DIAL
... ...
这类活动使用 startActivity(Intent)

标准意图的广播动作
Intent.ACTION_REBOOT
Intent.ACTION_BOOT_COMPLETE
Intent.ACTION_PACKAGE_ADD
Intent.ACTION_PACKAGE_


URI 包括 URL 和 URN

URL   网络通讯协议
URN   表示持久、专门机构负责事物，  比起网页。

URI 与 MIME
两者在形式上完全一样，只是MIME必须以"content://"开始，这是表示该数据类型优先于平台的数据类型。

format
schema://host:port/path    
例如：  weather://com.msi.manning/loc?zip=12345
"weather://" 是方案; "com.msi.manning" 是主机，也叫授权; "/loc" 是路径,"?zip=12345"
是路径。
再如： file:///tmp/android.txt
"file://" 是方案，"/tmp/android.txt" 是路径。

bob@google.com:80


"geo://", "tel://", "https://", "file://", "people://"

android.net.Uri;
StringUri
OpaqueUri                 mailto:nobody@google.com
HierarchicalUri           http://google.com

HierarchicalUri 没有 <authority> 和 <query>, 而 <path> 也只有 HierarchicalUri
才有。


Uri.java 内部类  AbstractHierarchicalUri 的方法 parseHost
静态内部类 PathPart 


UTF-8 是其默认的编码 DEFAULT_ENCODING
www.faqs.org/rfcs/rfc2396.html

BNF
<scheme>://<authority><path>?<query>
<authority><path>?<query> 也称 scheme-specific
<query> 一般形如 q=value

媒体文件类型
image/tiff, audio/mid, application/pdf



Android View 是单线程的， UI 操作并不是线程安全的， 必须在 UI 线程中执行，Handler 获取用户界面线程以外的线程来实现 UI 线程更新。

DeferredHandler

post, postAtTime  放入消息队列里，延迟执行。
sendMessage   handleMessage

Thread 类实现了 Runable

new Thread(this).start();
线程的入口函数是run方法，见 Runnable.java 的注释。
Thread.java  (libcore/luni-kernel/src/main/java/java/lang)  方法 
调用
VMThread.java (libcore/luni/src/main/java/java/lang) 方法 VMThread.create
，后者调用
java_lang_VMThread.c （dalvik/vm/native/）
函数Dalvik_java_lang_VMThread_create，这个函数再调用
Thread.c (dalvik/vm) 函数 dvmCreateInterpThread 。 dvmCreateInterpThread
调用pthread_create创建了新的线程，这个线程的入口函数是 interpThreadStart，
入口函数调用 stack.c (dalvik/vm/interp) 的 dvmCallMethod ，这里要注意到
dvmCallMethod 开始处的断言，确保 run->name 为 "run"，要找到 Java 层的 "run"
方法。然后，通过 dvmCallMethodV 调用到 dvmInterpret
(dalvik/vm/interp/Interp.c)，执行 run 方法。

dalvik/vm/Thread.[ch]


frameworks/base/libs/ui/EventHub.cpp:58:#define SEQ_MASK 0x7fff0000
frameworks/base/libs/utils/Threads.cpp:522:    condState->sema = CreateSemaphore(NULL, 0, 0x7fffffff, NULL);


Runable ，Run
Parcelable， Parcel
Drawable， 
Clonable
Observable （模板抽象类，即Object）， Observer
ContentObserver，  ContentObservable
DataSetObserver，  DataSetObservable
Compareable， Cloneable，Serializable, Appendable, Cloneable, Formattable,
Flushable,   Animatable, Readable
xxxable Java 包中的接口名称。
find frameworks/ libcore/   \( -name "*.java" \) | xargs grep --color -n -e "^\s*public\s*interface\s*\w*able "

MVC 模型

I was confused by the code of auto brightness control.
The following is the code in PowerManagerService.java,


netstat
su
adbd stop
setprop service.adb.tcp.port 5555
adbd start
netstat


libcore/luni/src/main/java/java/util/LinkedList.java  单链表
java.util.LinkedList     size,  removeFirst,  getFirst,   add , remove,  clear 等方法。


libcore/luni/src/main/java/java/lang/   String  字符串类
                                       Charsequence
                                       是一个接口，而且是处理有序的字符集合（序列）。
                                       Charset  字符集，


InputStreamRead in = new InputStreamReader (new FileInputStream(oldname),
                                            "BIG5");
OutputStreamWriter out = new OutputStreamWriter (new FileOutputStream(newname,
"GBK");

while ( (i = in.read()) >=0 )
    out.write(i);




setInputMethodLocked(String id) in InputMethodManagerService.


JNI

dalvik/vm/Jni.c
dalvik/vm/JniInternal.h
dalvik/vm/Native.c
dalvik/vm/Native.h


AndroidRuntime::registerNativeMethods 是个静态成员函数
frameworks/base/core/jni/AndroidRuntime.cpp
frameworks/base/include/android_runtime/AndroidRuntime.h   
AndroidRuntime 是个虚基类
onStarted
onZygoteInit
onExit



Android Activity间用Intent和Bundle传递参数
传递方：
　　//点击btn_sub传递 fieldHeight.getText()和 fieldWeight.getText()
　　private void setListeners(){
　　btn_sub.setOnClickListener(calrBMI);
　　}

　　private OnClickListener calrBMI = new OnClickListener()　　{
　　public void onClick(View v)　{
　　Intent intent = new Intent();
　　Bundle bundle = new Bundle();

　　bundle.putString("key_height", fieldHeight.getText().toString());
　　bundle.putString("key_weight", fieldWeight.getText().toString());
　　intent.setClass(ActivityMain.this,Report.class);

  　intent.putExtras(bundle);

　　startActivity(intent);
　　}
　　};

　　接收方：
　　Bundle bundle = new Bundle();

　　bundle = this.getIntent().getExtras();
　　double height = Double.parseDouble(bundle.getString("key_height"))/100;
　　double weight = Double.parseDouble(bundle.getString("key_weight"));





import android.Manifest;

这个类是文件 framework/base/core/res/AndroidManifest.xml 经 aapt 编译而产生。

=======================
First, be sure to build the source in order to get the rgb2565
executable.

Then, starting with a png (without transparency), do the following:

1. Convert the png to raw format, using imagemagick:
   convert -depth 8 myimage.png rgb:myimage.raw
2. Run rgb2565 against the png using the following:
   rgb2565 -rle < myimage.raw > myimage.rle
   ========================


我对这个文件还没仔细研究过，不过一个网友突然问了我一个问题，我也还是大概的知道一些。

    android的系统应用中的一个重要的进程就是zygote,所有的java应用程序进程都是由zygote派生出来的，zygote这个进程的作用就是“生儿子”。具体的一个应用如何出来的大家可以看我以前的一篇文章-----Android 应用初始化及窗体事件的分发。

   首先要了解一点初始化语言的基本知识吧：

Services（服务）是一个程序，他在初始化时启动，并在退出时重启（可选）。Services（服务）的形式如下：

       service <name> <pathname> [ <argument> ]*
          <option>
          <option>
Options为选项，具体可以参考linux　service命令
zygote进程正是在linux kernel startup后通过这个文件启动的，具体看init.rc中这一段：
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    socket zygote stream 666
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
一段一段的分析这个代码：
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
启动服务名字zygote.   /system/bin/app_process 进程的bin文件具体路径，后面跟的就是启动参数-Xzygote /system/bin --zygote --start-system-server。这段参数有什么作用可以对照看代码app_main.cpp
if (i < argc) {
        arg = argv[i++];
        if (0 == strcmp("--zygote", arg)) {
            bool startSystemServer = (i < argc) ? 
                    strcmp(argv[i], "--start-system-server") == 0 : false;
            setArgv0(argv0, "zygote");
            set_process_name("zygote");
           runtime.start("com.android.internal.os.ZygoteInit",
                startSystemServer);
        } else {
            set_process_name(argv0);

            runtime.mClassName = arg;

            // Remainder of args get passed to startup class main()
            runtime.mArgC = argc-i;
            runtime.mArgV = argv+i;

            LOGV("App process is starting with pid=%d, class=%s.\n",
                 getpid(), runtime.getClassName());
            runtime.start();
        }
    }

-Xzygote 这个参数的意义是在jvm中设置gDvm.zygote = true;至于这个参数的具体作用大家自己看代码吧。 其流程是 androidRuntime->start() call---> JNI_CreateJavaVM() call ---->dvmStartup()(戴维林虚拟机初始化) call---->dvmProcessOptions().

/system/bin :也许是告知系统应用的路径吧，大家看到了告诉我。

onrestart write /sys/android_power/request_state wake：

如果这个服务重启了，打开/sys/android_power/request_state 这个文件写入wake字符串。

{{{1
MultiMedia
frameworks/base/media
opencore development document
external/opencore/doc
}}}1



In Android goldfish kernel I have to fix CONSISTEN_DMA_SIZE and also
> set CONFIG_FORCE_MAX_ZONEORDER=12 so that framebuffer driver can
> allocate memory without any problem.

CONFIG_FRAMEBUFFER_CONSOLE 







Network Time is not auto updating with some service provider
http://en.wikipedia.org/wiki/NITZ

http://azero.tsang.blog.163.com/
Android手机应用程序界面设计指南系列（3）——交互模式 




app/UiModeManager.java

ACTION_ENTER_DESK_MODE
platform$ find . -name "*.java" | xargs grep --color -n -e "showCallScreen"
./packages/apps/Contacts/src/com/android/contacts/TwelveKeyDialer.java:1039:            if (phone != null) phone.showCallScreenWithDialpad(showDialpad);
./packages/apps/Contacts/src/com/android/contacts/TwelveKeyDialer.java:1041:            Log.w(TAG, "phone.showCallScreenWithDialpad() failed", e);
./packages/apps/Contacts/src/com/android/contacts/TwelveKeyDialer.java:1046:        // Note that we do this whether or not the showCallScreenWithDialpad()
./packages/apps/Contacts/src/com/android/contacts/DialtactsActivity.java:191:                if (callKey && phone != null && phone.showCallScreen()) {
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:258:    private boolean showCallScreenInternal(boolean specifyInitialDialpadState,
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:280:    public boolean showCallScreen() {
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:281:        return showCallScreenInternal(false, false);
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:284:    // The variation of showCallScreen() that specifies the initial dialpad state.
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:285:    // (Ideally this would be called showCallScreen() too, just with a different
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:287:    public boolean showCallScreenWithDialpad(boolean showDialpad) {
./packages/apps/Phone/src/com/android/phone/PhoneInterfaceManager.java:288:        return showCallScreenInternal(true, showDialpad);
./frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java:694:            if (phone != null && phone.showCallScreen()) {
./out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/telephony/java/com/android/internal/telephony/ITelephony.java:70:case TRANSACTION_showCallScreen:
./out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/telephony/java/com/android/internal/telephony/ITelephony.java:73:boolean _result = this.showCallScreen();

base/telephony/java/com/android/internal/telephony/ITelephony.aidl:    boolean showCallScreen();

①  usb有主从设备之分，主设备有：pc, 现在市面上的那些插u-disk即可播放mp3的“mp3”之类的，
usb 信号是差分信号，信号线为D+, D-,。 在usb host 端， D+，D- 各接一个15kohm 的下拉电阻， 而在usb device端，这时就有高速低速设备的区别了。usb1.0, 1.1,2.0协议中都有定义高低速设备以满足不同情况的需求，这些在硬件上的区别就是： 高速设备：d+ 接一个1.5kohm的上拉电阻，d-不接；低速设备则相反。
      这样当usb device 插入到host中时，如果是高速设备， 则d+被拉高，d-不变；低速设备则与之相反。 这个上拉过程需要大概2.5us的时间，host这这个时间内便检测到了该信号，即可判断有device plug in，和该device的类型，然后开始通讯，枚举。。。等。

②　　USB OTG（on the go） 就是既可以做host又可以做client
我们一般是作为client接受pc传输数据，作为host时可以接打印机直接把手机中的照片打印出来
判别是host还是client是靠USB_ID这根pin

当作为client时，USB_ID基本是悬空的（内部有上拉）

如果侦测到USB_ID被拉低，就被认为是作为host，向外输出
所以需要外部client设备把USB_ID拉低

========================SDIO============================================================
SD（Secure Digital）与 MMC（Multimedia Card）
SD 是一种 flash memory card 的标准，也就是一般常见的 SD 记忆卡，而 MMC 则是较早的一种记忆卡标准，目前已经被 SD 标准所取代。在维基百科上有相当详细的 SD/MMC 规格说明：[http://zh.wikipedia.org/wiki/Secure_Digital]。

SDIO（Secure Digital I/O）
SDIO 是目前我们比较关心的技术，SDIO 故名思义，就是 SD 的 I/O 接口（interface）的意思，不过这样解释可能还有点抽像。更具体的说明，SD 本来是记忆卡的标准，但是现在也可以把 SD 拿来插上一些外围接口使用，这样的技术便是 SDIO。

所以 SDIO 本身是一种相当单纯的技术，透过 SD 的 I/O 接脚来连接外部外围，并且透过 SD 上的 I/O 数据接位与这些外围传输数据，而且 SD 协会会员也推出很完整的 SDIO stack 驱动程序，使得 SDIO 外围（我们称为 SDIO 卡）的开发与应用变得相当热门。

现在已经有非常多的手机或是手持装置都支持 SDIO 的功能（SD 标准原本就是针对 mobile device 而制定），而且许多 SDIO 外围也都被开发出来，让手机外接外围更加容易，并且开发上更有弹性（不需要内建外围）。目前常见的 SDIO 外围（SDIO 卡）有：

    * Wi-Fi card（无线网络卡）
    * CMOS sensor card（照相模块）
    * GPS card
    * GSM/GPRS modem card
    * Bluetooth card
    * Radio/TV card（很好玩）

SDIO 的应用将是未来嵌入式系统最重要的接口技术之一，并且也会取代目前 GPIO 式的 SPI 接口。

SD/SDIO 的传输模式
SD 传输模式有以下 3 种：
    * SPI mode（required）
    * 1-bit mode
    * 4-bit mode

SDIO 同样也支持以上 3 种传输模式。依据 SD 标准，所有的 SD（记忆卡）与 SDIO（外围）都必须支持 SPI mode，因此 SPI mode 是「required」。此外，早期的 MMC 卡（使用 SPI 传输）也能接到 SD 插糟（SD slot），并且使用 SPI mode 或 1-bit mode 来读取。

SD 的 MMC Mode
SD 也能读取 MMC 内存，虽然 MMC 标准上提到，MMC 内存不见得要支持 SPI mode（但是一定要支持 1-bit mode），但是市面上能看到的 MMC 卡其实都有支持 SPI mode。因此，我们可以把 SD 设定成 SPI mode 的传输方式来读取 MMC 记忆卡。

SD 的 MMC Mode 就是用来读取 MMC 卡的一种传输模式。不过，SD 的 MMC Mode 虽然也是使用 SPI mode，但其物理特性仍是有差异的：

    * MMC 的 SPI mode 最大传输速率为 20 Mbit/s；
    * SD 的 SPI mode 最大传输速率为 25 Mbit/s。

为避免混淆，有时也用 SPI/MMC mode 与 SPI/SD mode 的写法来做清楚区别。
============================SDIO=============================================



http://dl.google.com/io/2009/pres/W_0300_CodingforLife-BatteryLifeThatIs.pdf



参考网站地址  ：
http://androidappdocs.appspot.com   （Google android 的sdk文档。）
http://androidappdocs.appspot.com/guide/developing/tools/adb.html#sqlite
http://androidappdocs.appspot.com/guide/developing/tools/traceview.html
以及
http://www.eoeandroid.com/
sqlite3 /data/data/com.android.providers.settings/databases/settings.db update system set value='1' where name='accelerometer_rotation';

leo@leo-desktop:~/android_2.1_20100506$ find ./ -iname ArrayList.java
./android/libcore/luni/src/main/java/java/util/ArrayList.java
leo@leo-desktop:~/android_2.1_20100506$ find ./ -iname HashMap.java
./android/libcore/luni/src/main/java/java/util/HashMap.java



Dual-Mode Subscriber Station (DMSS) or Advanced Mode Subscriber
 Software (AMSS)

/usr/share/java/javassist.jar
/usr/local/jvm/  tool.jar    com.sun.mirror.apt 

/usr/share/java/javassist.jar
javax.jnlp.*       /usr/lib/jvm/java-6-sun-1.6.0.22/jre/lib/javaws.jar
libxom-java

swt   
.classpath 文件

<classpath>
        <classpathentry kind="src" path="."/>
        <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
	<classpathentry kind="output" path="bin"/>
</classpath>

 bionic/libc/bionic/stubs.c   

    snprintf(state->group_name_buffer, sizeof state->group_name_buffer,
             "app_%u", gid - AID_APP);

代码检查
cppcheck -v -s -f -a -I bo2 -I pg "代码路径(文件夹或者文件)"  1>>/dev/null

Not getting console prompt...
Add "init=/init" to your bootargs..


There is a device config value that needs to be set:
frameworks/base/core/res/res/values/config.xml has a value called
config_tether_usb_regexs.  This is designed to be an overlaid resource
(you don't change the standard file, you make a build that includes an
overlay dir and have a frameworks/base/core/res/res/values/config.xml file
there that just has the values defined that differ from the defaults for
your project).  If your interface is called "usb0" you could add a "usb.*"
regex to match that (in case of race conditions where you may sometimes get
a usb1).

System setProperty and getProperty
In what way did you manage to invoke these apis? Did you use any hacks?
Personally, I still consider it's not a good way to perform IPC between different apks with property.
1. The number of slots in property system is limited, if I recall correctly, around 250.
2. Once occupied, a slot can't be freed.
3. The api isn't intended for external usage.
So, if an application makes heavy use of properties, slots will be soon be exhausted. And system service may fail due to this. Another risk is the apk is bound to an internal api which may fail to work in any future version, thus break application compatibility.
system/core/init/property_service.c for
permission registration


        
   The following commit helped resolve the issue,

[ARM] Do not call flush_cache_user_range with mmap_sem held

We can't be holding the mmap_sem while calling flush_cache_user_range
because the flush can fault. If we fault on a user address, the
page fault handler will try to take mmap_sem again. Since both places
acquire the read lock, most of the time it succeeds. However, if
another
thread tries to acquire the write lock on the mmap_sem (e.g. mmap) in
between the call to flush_cache_user_range and the fault, the
down_read
in do_page_fault will deadlock.

Also, since we really can't be holding the mmap_sem while calling
flush_cache_user_range AND vma is actually unused by the flush itself,
get rid of vma as an argument.
       
        
The problem is really minor - the duplication only happens when multiple compilation requests for the same trace are entered in the compiler queue, and micro benchmarks with tight tiny loops happen to fit the timing criteria. The compiled code of the last compilation request will be dispatched so the performance impact is negligible albeit a small number of wasted bytes in the code cache.

The fix is trivial too. Since you can spot this problem you should be able to figure out where to patch the code in red. :-)

1) dalvik/vm/compiler/Frontend.c:dvmCompileTrace()

    /* If we've already compiled this trace, just return success */
    if (dvmJitGetCodeAddr(startCodePtr) && !info->discardResult) {
        /*
         * Make sure the codeAddress is NULL so that it won't clobber the
         * existing entry.
         */
        info->codeAddress = NULL;
        return true;
    }

2) dalvik/vm/compiler/Compiler.c:compilerThreadStart()

                    } else if (!work.result.discardResult &&
                               work.result.codeAddress) {
                        dvmJitSetCodeAddr(work.pc, work.result.codeAddress,
                                          work.result.instructionSet);
                    }

Hope this helps,
-Ben







[platform/frameworks/base.git] / services / java / com / android /
server /  UsbObserver.java

[platform/frameworks/base.git] / services / java / com / android /
server /  MountService.java



Look at drivers/usb/gadged/f_adb.c, android.c



sdk/jarutils/src/com/android/jarutils/KeystoreHelper.java
sdk/jarutils/src/com/android/jarutils/DebugKeyProvider.java
keytool -genkey -alias AndroidDebugKey -keyalg RSA -dname  "CN=Android Debug,O=Android,C=US"    -validity 365 \
    -keypass android -keystore debug.keystore   -storepass android

https://github.com/getfatday/keytool-importkeypair.git
/home/leo/code/script/keytool-importkeypair
 keytool-importkeypair -k ~/.android/debug.keystore -p android -pk8 platform.pk8 -cert platform.x509.pem -alias platform

SourceForge password xs10525
