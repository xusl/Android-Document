\documentclass[a4paper,titlepage]{article}
%\usepackage[a4paper,marginparwidth={2cm}]{geometry}
%\usepackage{mdwlist}%“压缩格式”的列表环境
%\usepackage{paralist}
% The following is needed in order to make the code compatible
% with both latex/dvips and pdflatex.
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\usepackage{longtable}
\usepackage{footnote}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{ifthen}
\usepackage{multicol}
\usepackage{underscore}
\usepackage{enumitem}
\usepackage{xeCJK}
\setCJKmainfont{AR PL UKai CN}
%\setCJKfamilyfont{kai}{AR PL UKai CN}
\setmainfont{DejaVu Sans}%\rmfamily 
\setsansfont{DejaVu Sans}%\sffamily
\setmonofont{DejaVu Sans Mono}%\ttfamily
\usepackage{makeidx}
\usepackage[iso]{isodateo}
\usepackage{listings}
%\usepackage{lstdoc}
\usepackage{textcomp}
%\usepackage[T1]{fontenc}
\lstset{language=,
    breaklines=true,
    extendedchars=false,
    escapeinside=``,%' ,
    breakautoindent=true,
    breakindent=10pt,
    numbers=left, 
    basicstyle=\ttfamily\scriptsize,
    %numberstyle=\tiny,
    %keywordstyle=\tiny\color{blue!70}, 
    keywordstyle=\color{blue!70}, 
    commentstyle=\color{red!50!green!50!blue!50},
} 
\usepackage{xcolor}
\usepackage{longtable}
\usepackage[CJKbookmarks=true, bookmarksnumbered=true,
colorlinks=true, citecolor=magenta, linkcolor=blue]{hyperref}
\title{How to debug when developing Android system}
\author{Leo shecenon@gmail.com}
\date{\today}
\makeindex

\makesavenoteenv{tabular}

\marginparwidth 100pt
\newcommand{\marginal}[1]{%
\leavevmode\marginpar{\footnotesize\raggedright#1\par}}

%加入\makeatletter;\makeatother的原因是命令中有@符号
%解决表格浮动问题
\makeatletter
\newcommand{\figcaption}{\def\@captype{figure}\caption}
\newcommand{\tabcaption}{\def\@captype{table}\caption}
\makeatother

\begin{document}
\maketitle
\renewcommand{\refname}{参考文献}
\renewcommand\contentsname{目录}
\renewcommand\listfigurename{插图目录}
\renewcommand\listtablename{表格目录}
\renewcommand\indexname{索引}
\renewcommand\appendixname{附录}
\renewcommand\figurename{图}
\renewcommand\tablename{表}
\renewcommand{\lstlistlistingname}{代码列表集}
\renewcommand{\lstlistingname}{代码}
%\setdescription{style=nextline}
%\setitemize{style=nextline}
%\newcommand\litem[1]{\item{\bfseries #1,\enspace}}
%\renewcommand{\descriptionlabel}[1]%
%{\hspace{\labelsep}\bfseries \sffamily #1, \enspace}

\makeatletter
\let\VERBATIM\verbatim
\def\verbatim{%
\def\verbatim@font{\footnotesize\ttfamily}%
\VERBATIM}

\newenvironment{myverbatim}%
{\verbatim\def\verbatim@font{\tiny\ttfamily}}%
{\endverbatim}

\makeatletter

\begin{multicols}{2}
\tableofcontents
\listoftables
\listoffigures
\end{multicols}

%\def\verbatim@font{\normalfont\ttfamily\hyphenchar\font\m@ne\@noligs}
%\renewcommand{\verbatim@font}{\normalfont\ttfamily}
% 设置中文正文字号
\newlength{\mmfontsize}
\setlength{\mmfontsize}{11pt}
% 段落间距
\setlength{\parskip}{0pt}
% list 参数配置命令
\renewcommand{\labelitemii}{$\circ$}
\newcommand{\listparam}{\setlength{\parsep}{\parskip}
\setlength{\itemsep}{0ex}% plus 0.1ex}
\setlength{\labelwidth}{2\mmfontsize}
\setlength{\labelsep}{.5\mmfontsize}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\leftmargin}{2\mmfontsize}
}%end listparam command

\begin{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\catcode`\@=12
\newcount\xuslcount
\xuslcount=1 {\xuslcount=2 } \show\xuslcount
\typeout{\marginparwidth xxxxxx}
\message{xx ^^j  sdfsd dfsdf}
{\def\a{b}\a
\def\foo#1?#2\par{\set{#1!}\set{#2?}}
\show\foo
%\output {xx}

\scrollmode
\tracingoutput9
\tracingonline1

\font\tenroman=cmr10 \tenroman
\setbox0=\hbox{g}
%\showbox0

\ifx\a\empty \ a is empty
\else
\textbackslash a is \a
\fi
}
\def\ifEqString#1#2%
    {\def\csa{#1}\def\csb{#2}\ifx\csa\csb }

    \ifEqString{good}{good}
    sssss
    \fi
%\showthe{\textwidth}
usb^^+
\includegraphics{mu.mps}
\end{comment}

\section{主机与Android目标机的通讯}
\subsection{usb}
C110 上的多个端点，除了U盘， adb这两个端点， fastboot也有个端点， 只是她是
uboot提供的usb驱动。 而recovery 模式的adb的端点跟 常规的adb的端点好像不同。
在连接到开发机器出现如下错误信息：
\begin{verbatim}
$adb shell
error: insufficient permissions for device 
\end{verbatim}
用 adb devices查看，得到如下信息：
\begin{verbatim}
$ adb devices
List of devices attached
???????????? no permissions
\end{verbatim}

  SDK 中的文档 docs/guide/developing/device.html 给出了解决方法：

If you're developing on Ubuntu Linux, you need to add a rules file that contains a USB configuration for each type of device you want to use for development. Each device manufacturer uses a different vendor ID. The example rules files below show how to add an entry for a single vendor ID (the HTC vendor ID). In order to support more devices, you will need additional lines of the same format that provide a different value for the SYSFS{idVendor} property. For other IDs, see the table of USB Vendor IDs, below.
\begin{verbatim}
1. Log in as root and create this file: /etc/udev/rules.d/51-android.rules.
For Gusty/Hardy, edit the file to read:
SUBSYSTEM=="usb", SYSFS{idVendor}=="0bb4", MODE="0666"
For Dapper, edit the file to read:
SUBSYSTEM=="usb_device", SYSFS{idVendor}=="0bb4", MODE="0666"
2.Now execute:
chmod a+r /etc/udev/rules.d/51-android.rules
\end{verbatim}

USB Vendor IDs 可以用lsusb查看，Samsung 的设备是 04e8，Google Vendor ID 18d1
 \footnote{厂商设备ID列表见： http://www.linux-usb.org/usb.ids}

\begin{verbatim}
$ lsusb
Bus 002 Device 003: ID 413c:2003 Dell Computer Corp. Keyboard
Bus 002 Device 002: ID 0461:4d22 Primax Electronics, Ltd
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 001 Device 010: ID 18a1:0002
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
\end{verbatim}
上面的id是18a1 没有销售商名，它就是设备的 Vendor ID。                                 

最新版本Ubuntu中SYSFS被ATTRS替换了。我的Lucid Lynx上可以使用的配置：
\begin{verbatim}
$ cat /etc/udev/rules.d/51-android.rules 
SUBSYSTEM=="usb", ATTRS{idVendor}=="18a1", MODE="0666"
\end{verbatim}

修改51-android.rules不需要重启Linux机器， 只需重启 udev 服务
\verb|$sudo service udev restart|
重新插拔一下设备就可以了。再次运行adb devices就可以看到你的设备已经连接

\begin{verbatim}
$ adb devices
List of devices attached
0403502001011000  device
\end{verbatim}

 模拟器链接adb shell不会出现这个问题。

\subsubsection{adb}
ADB 是 Andrdoi Debug Bridge （Android 调试桥 ） 的简称，是Android 调试的利器 。

\begin{tabular}{|p{0.5\linewidth}|p{0.5\linewidth}|}\hline
adb shell & 进入ADB shell \\\hline
adb devices & 列出挂接的设备，取得当前运行的模拟器/设备的实例状态\\\hline
adb connect <host>:<port> & connect to a device via TCP/IP \\\hline
adb start-server & 启动 adb 服务，如果在使用adb时，没有adb服务，会自动开启此服务。\\\hline
adb kill-server & 停止 adb 服务。\\\hline
adb bugreport & 获取设备的全部状态信息，在 bug report 中也写入此命令的输出。\\\hline
adb install [-r] [-s] [-l] xxx.apk & -r参数会强制卸载老版本，安装新版本。 -s 表示安装到SD Card中。'-l' means forward-lock the app\\\hline
adb uninstall [-k] xxx.apk & 卸载软件， -k 表示保留数据和缓存目录。                 \\\hline
adb remount & /system重新挂载为可读写。\\\hline
adb push test.txt /data/test.txt & 把主机当前目录的test.txt复制到设备或模拟器上的/tmp/test.txt\\\hline
adb pull /system/lib/libwebcore.so ./ &把设备或模拟器上的文件/system/lib/libwebcore.so拷贝到主机当前目录中。\\\hline
adb get-serialno & 打印设备的端口名称。\\\hline
adb forward <local> <remote> & adb forward tcp:5555 tcp:8000 设置主机5555端口号转发到模拟器或设备8000端口。\\\hline
adb help & 打印 adb 帮组信息\\\hline
\end{tabular}

-d 选项  把子命令发送到USB device 
-e 选项  把自命令发送到 emulator

system/core/adb  代码，  system/core/adb/SERVICES.txt


adbd 服务 , 内核有adb驱动。


adb 自动补全， ics 4.0 有个脚本， 启用方式
source sdk/bash_completion/adb.bash
或者
. sdk/bash_completion/adb.bash
或者
sudo cp sdk/bash_completion/adb.bash /etc/bash_completion.d/

\subsection{串口}
选择 kermit 或者 minicom, 个人喜欢kermit，配置如下：
\begin{lstlisting}[caption=kermit的配置.kermrc, xleftmargin=8em,xrightmargin=8em, aboveskip=1em]
set line            /dev/ttyUSB0
set speed           115200
set carrier-watch   off
set handshake       none
set flow-control    none
robust
set file type       bin
set file name       lit
set rec pack        1000
set send pack       1000
set window          5
c
\end{lstlisting}

/dev/ttyUSB* 是Usb模拟串口。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{日志}
\subsection{logcat}
Logcat 查看log ，一般格式logcat [options] [filterspecs]
\begin{verbatim}
$adb logcat                       #打印main缓冲区里的信息 
$adb logcat -b radio              #打印radio缓冲区里的信息 
$adb logcat -b radio -b main      #打印radio、main里的信息
或者
$adb logcat -b radio &; adb logcat -b main&    #串口下
\end{verbatim}
 

如： adb logcat  -f  /data/data/droid.log -r 2  -n 10
\begin{description}
    \item [默认格式，即 -v brief]
        D/View    (   51): android.widget.TextView@43f0fc10 View.setFrame(125,0,163,25) 

    \item [-v long]
        \verb|[ 01-01 08:47:00.210    51:0x3d D/View     ] |\\
        com.android.server.status.DateView@43dacf00 View.setFrame(0,0,31,25)

    \item [-v thread]
        D(   51:0x3d) com.android.server.status.DateView@43dacf00 View.setFrame(0,0,31,25)

    \item [-v raw]
        android.widget.FrameLayout@43f3a688 View.setFrame(100,0,125,25) 
\end{description}

        logcat 过滤器
先看看默认的输出
D/View    (   51): android.widget.TextView@43f0fc10 View.setFrame(125,0,163,25) 
过滤器就是根据上面红色部分过滤的。
其中 D 表示 Debug，是优先级，也就是Log.d 打印的; View表示的Tag，即Log.d的第一个参数。
要只打印上面部分，可以输入：
\verb|$adb logcat   View:d|

更多详细帮组请键入：
\verb|$ adb logcat  --help  #在adb shell里，logcat --help   |



\subsection{logcat options}

\begin{tabular}{| p{0.45\linewidth} | p{0.55\linewidth} |}\hline
-b [main|radio|system|events] & 指定消息的Buffer，其中main、radio、system保存在/dev/log/下，event比较特殊，它是打开os-events相关的log打印，默认被写入到手机的/data/anr/traces.txt文件中。\\\hline
-c & 清理（Clear）buffer。\\\hline
-d & 把buffer中的日志转储（Dump）,即打印并退出，并不等待。\\\hline
-v <format> & 输出日志消息的格式。默认是brief。process tag thread raw time threadtime long \\\hline
-f <filename> & 把日志消息写到指定的文件<filename>，默认是写到标准输出(stdout)\\\hline
-r [<kbytes>] & 当日志文件达到<kilobytes>时，清空文件，循环记录。默认是16。需要 -f。\\\hline
-n <count> & 循环记录的次数，默认是4。\\\hline
\end{tabular}

可以把 logcat 的输出重定向，那么可以在 sh 或 adbd 之前启动 logcat。
if you can get trace via debug port, you  can start logcat very
early from your init.rc, way before you get shell or adb.
service logcat /system/bin/logcat -f /dev/kmsg
       oneshot

在发生anr时会记录
service dumpstate /system/bin/dumpstate -s
    socket dumpstate stream 0660 shell log
    disabled
    oneshot

把日志保存：
service logcat /system/bin/logcat -v time -f /data/logcatoutput -r 256 -n 12
    user root
\#    disabled
   oneshot


\subsection{如何向logcat输出}
\subsubsection{Java 的 打印信息 }
主要是使用两个类 Log(android.util.Log)
和 Slog(android.util.Slog)
\begin{verbatim}
方法原型：Log.v(String tag, String msg);
使用举例：Log.v("Foo","Hello world");
\end{verbatim}
除了v，还有其他的方法： 
\tabcaption{Log的各种打印方法}
\begin{tabular}{|l|c|l|}\hline
v   &Verbose &冗余消息，优先级最低。 \\\hline
d   &Debug   &调试消息，优先级比 Verbose 高一级。 \\\hline
i   &Info    &普通消息，优先级比 Debug 高一级。 \\\hline
w   &Warn    &警告消息，优先级比 Info 高一级。 \\\hline
e   &Error   &错误消息，优先级最高。 \\\hline
\end{tabular}

Slog 与 Log 类似，区别在于， SLog 把消息送往 system 缓冲区里，而 Log 把消息送
往了 main 缓冲区。其中的 v, d, i, w, e 的含义与 Log 中的相同。
但是，看了源码之后，发现把Log日志的文件句柄赋给了SLog。所以，实际上SLog也是往
main Buffer打印。

\begin{lstlisting} 
W/PackageManager(   59): Not granting permission android.permission.SEND_DOWNLOAD_COMPLETED_INTENTS to package com.android.browser (protectionLevel=2 flags=0x1be45) 
\end{lstlisting}
就是PackageManagerService.java\footnote{frameworks/base/services/java/com/android/server/}用Slog.w打印出来的。


此类的调用栈如下： 
\begin{verbatim}
frameworks/base/core/java/android/util/Log.java   -> Log.d("HellWorld","detail"); 
frameworks/base/core/jni/android_util_Log.cpp     -> android_util_Log_println_native 
system/core/liblog/logd_write.c     -> __android_log_buf_write 
 最后调用系统函数 writev, 进入内核 Android Log 驱动。
main、radio、events、system，见 system/core/include/cutils/logger.h。
\end{verbatim}

System.out.println 是直接向控制台输出，而不输向logcat。


\subsubsection{打印堆栈}
打印出的当前函数调用关系\\
\lstinline{new Exception().printStackTrace();}\\
这个是 Dalvik VM 级别的打印信息：
\begin{verbatim}
W/System.err(  296): java.lang.Exception: print stack trace 
W/System.err(  296): 	at com.android.launcher2.DragController.startDrag(DragController.java:170) 
W/System.err(  296): 	at com.android.launcher2.Workspace.startDrag(Workspace.java:1048) 
W/System.err(  296): 	at com.android.launcher2.Launcher.onLongClick(Launcher.java:1622) 
W/System.err(  296): 	at android.view.View.performLongClick(View.java:2427) 
W/System.err(  296): 	at android.widget.TextView.performLongClick(TextView.java:7295) 
W/System.err(  296): 	at android.view.View$CheckForLongPress.run(View.java:8795) 
W/System.err(  296): 	at android.os.Handler.handleCallback(Handler.java:587) 
W/System.err(  296): 	at android.os.Handler.dispatchMessage(Handler.java:92) 
W/System.err(  296): 	at android.os.Looper.loop(Looper.java:123) 
W/System.err(  296): 	at android.app.ActivityThread.main(ActivityThread.java:4627) 
W/System.err(  296): 	at java.lang.reflect.Method.invokeNative(Native Method) 
W/System.err(  296): 	at java.lang.reflect.Method.invoke(Method.java:521) 
W/System.err(  296): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:868) 
W/System.err(  296): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:626) 
W/System.err(  296): 	at dalvik.system.NativeStart.main(Native Method) 
\end{verbatim}

Throwable类（libcore/luni-kernel/src/main/java/java/lang/Throwable.java ）还有其他的API 可以供调试之用。


\subsection{JNI 和 C/C++库的 打印信息}
AndroidRuntime::start\footnote{frameworks/base/core/jni/AndroidRuntime.cpp}
成员函数调用 \\
\lstinline{LOGD("\n>>>>>>>>>>>>>> AndroidRuntime START <<<<<<<<<<<<<<\n"); }\\
在系统启动时打印了这条消息。 

除了LOGD，还有LOGV，LOGI，LOGW，LOGE，SLOGD，SLOGV，SLOGI，SLOGW，SLOGW ，等等
，详细请见头文件log.h\footnote{system/core/include/cutils/log.h}。这些都是对函数
android_printLog包装的宏。


LOGV 默认情况下是不打印的。如果要输出LOGV消息，请在包含utils/Log.h前定义宏LOG_NDEBUG
(这是system/core/include/cutils/log.h 说明的。)
\begin{lstlisting}
    #define LOG_NDEBUG 0
    . . . . . .
    #include <utils/Log.h>
\end{lstlisting}

如果需要在C程序中加打印语句，有两种方法
1)  直接在代码中使用printf，此方法只能应用于从命令行启动程序的情况，运行时可以adb shell中看到打印信息
2)  使用程序中提供的重定项后的打印语句，并在logcat中看到它
例如在libdvm.so中使用
\lstinline{dvmFprintf(stderr, “xieyan log\n”);}

Printf 函数也可以使用。具体细节待研究。



\subsection{logwrapper}\cite{logwrapper}
Android本地应用程序的调试信息一般通过LOGI、LOGD、LOGE等android
logger提供的函数进行程序的debug，但是有时候某些本地应用使用的是printf等c库里的
函数进行数据输出，如果这些程序是由init进程执行，那么使用printf等函数的输出内容
无法显示在终端上（android在init中做了手脚），甚至某些进程可能会遇到段错误等意
外退出的情况，这种情况常见于最初porting android源码时。

如何解决上面提到的问题呢？Android提供了一个小工具，叫做logwrapper，用来处理上
面提到的情况，使用方法就是将可执行文件的路径作为logwrapper的参数，比如你可以在
init.rc中这样写：
\begin{lstlisting}
 service adbd /system/bin/logwrapper /sbin/adbd 
     disabled 
 \end{lstlisting}

这样adbd中使用printf函数的输出都会从logcat中显示出来。

我这里描述一下logwrapper的原理，看logwrapper是如何利用伪终端机制来监视一个进程的STDOUT和STDERR。
伪终端是由主终端和从终端这两个构成的。
\begin{description}[nolistsep]
    \item [logwrapper打开主终端]
        parent_ptty = open("/dev/ptmx", O_RDWR);

    \item [获取从终端的名字] 
        child_devname = (char*)ptsname(parent_ptty) 

    \item [fork子进程，然后在子进程中打开从终端] 
        child_ptty = open(child_devname, O_RDWR);

    \item [接下来，把子进程的STDOUT和STDERR重定向到从终端] 
        dup2(child_ptty, 1); 
        dup2(child_ptty, 2); 

    \item [最后，调用child函数运行程序] 
        child(argc - 1, \&argv[1]);

    \item [父进程最后调用parent()函数并进入循环读取主终端中的数据] 
        即，子进程的程序向从终端输出的数据，并存放在char buffer[4096]中。当子进程
        的输出数据填满buffer时，父进程会向/dev/log/*下面的设备flush一次。子进程执
        行完毕后再flush一次，最后打印出子进程终止的信息。
\end{description}

\subsection{dmesg 和 printk}
\subsubsection{原理}
记得在编译linux内核make menuconfig的时候设定输出信息到console,要修改
CONFIG_CMDLINE的内容,但是自始至终也没搞懂为何这样设置就可以把打印信息从串口输
出呢? 带着这个疑问,我查看了linux的printk函数,最后找到了答案.
\begin{enumerate}
    \item  printk 函数

printk函数首先把要打印的信息放到buffer里面,然后调用release_console_sem最后调用
到相关驱动的write函数,如果你设定了 \\*
\fbox{CONFIG_CMDLINE="console=ttySL0,19200},\\*那么printk信息就会调用ttySL这个
驱动的write函数,也就是从串口输出数据了.在__call_console_drivers里面有一个很重
要的变量console_drivers,它决定了调用哪支driver输出printk信息.

\begin{lstlisting}
printk() {
  ..............  
 //把待输出文字放入buffer
 va_start(args, fmt);
 printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 va_end(args); 
   ..............  
 release_console_sem();
       |
       ---void release_console_sem(void) {
           .............
           _call_console_drivers
                 |
                 ---static void __call_console_drivers(unsigned long start, unsigned long end) {
                    struct console *con;
                   
                    for (con = console_drivers; con; con = con->next) {
                     if ((con->flags & CON_ENABLED) && con->write)
                      con->write(con, &LOG_BUF(start), end - start);
                    }
                  }
              }
}
\end{lstlisting}

\item 选择console driver 
下面就是printk如果确定调用哪个driver的write函数输出信息过程,或者说一个console driver选择的过程.
首先看一下linux内核启动代码:

\begin{lstlisting}
asmlinkage void __init start_kernel(void) {
  ..........  
 setup_arch(&command_line);
 printk("Kernel command line: \%s\n", saved_command_line);
 parse_options(command_line);
  ..........
}

parse_options {
 // 关键调用
 checksetup(line)
      |
      --------int __init checksetup(char *line) {
        struct kernel_param *p;
       
        if (line == NULL)
         return 0;
       
        p = &__setup_start;
        do {
         int n = strlen(p->str);
         if (!strncmp(line,p->str,n)) {
          if (p->setup_func(line+n))
           return 1;
         }
         p++;
        } while (p < &__setup_end);
        return 0;
       }
}
\end{lstlisting}

setup_arch根据CONFIG_CMDLINE指定的内容设定command_line指针. parse_options会遍
历一个kernel_param结构数组,起始于__setup_start, 终止于__setup_end,

\begin{lstlisting}
struct kernel_param {
 const char *str;
 int (*setup_func)(char *);
};
\end{lstlisting}
此数组里面的数据均来自于__setup(str, fn)这个宏.
\begin{lstlisting}[caption=Init.h]
#define __setup(str, fn)        \
 static char __setup_str_##fn[] __initdata = str;    \
 static struct kernel_param __setup_##fn __attribute__((unused)) __initsetup = { __setup_str_##fn, fn }
\end{lstlisting}

在printk.c里面有一个很重要的语句
\\*\fbox{__setup("console=", console_setup);}\\*
这句话也就是说当CONFIG_CMDLINE含有"console="字符的话,就调用
console_setup函数, 所以在parse_options调用的时候,就会调用到console_setup函数,
console_setup就会记录下来console驱动的name,以及一些选项参数到console_cmdline数
组中(如波特率),设置preferred_console参数,这样console driver已经选择好一半了.

\begin{lstlisting}
console_setup() {
  ..............  
 for(i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0]; i++)
  if (strcmp(console_cmdline[i].name, name) == 0 &&
     console_cmdline[i].index == idx) {
    preferred_console = i;
    return 1;
  }
 if (i == MAX_CMDLINECONSOLES)
  return 1;
 preferred_console = i;
 c = &console_cmdline[i];
 memcpy(c->name, name, sizeof(c->name));
 c->options = options;
 c->index = idx; 
  ..............
}
\end{lstlisting}

选择console driver的另一半来自于register_console(linux启动后也会调用此函数),register_console
最重要的一句话是console->next = console_drivers;这样就完成了选择console driver的全过程.

\begin{lstlisting}
void register_console(struct console * console) {
   ..............
   
// 找到 console_driver 的过程
 for(i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0]; i++) {
  if (strcmp(console_cmdline[i].name, console->name) != 0)
   continue;
  if (console->index >= 0 &&
      console->index != console_cmdline[i].index)
   continue;
  if (console->index < 0)
   console->index = console_cmdline[i].index;
  if (console->setup &&
      console->setup(console, console_cmdline[i].options) != 0)  //此时做了setup的动作.
   break;
  console->flags |= CON_ENABLED;
  console->index = console_cmdline[i].index;
  if (i == preferred_console)
   console->flags |= CON_CONSDEV;
  break;
 }

 if (!(console->flags & CON_ENABLED))
  return; //屏蔽掉其他非console的driver  
  
  if ((console->flags & CON_CONSDEV) || console_drivers == NULL) {
  console->next = console_drivers;
  console_drivers = console; //设定console_driver
 } else {
  console->next = console_drivers->next;
  console_drivers->next = console;
 }
   ..............
}
\end{lstlisting}

\begin{lstlisting}[caption=Setup.c]
__tagtable(ATAG_CMDLINE, parse_tag_cmdline);
static int __init parse_tag_cmdline(const struct tag *tag) {
 strncpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
 default_command_line[COMMAND_LINE_SIZE - 1] = '\0';  //放到default_command_line中
 return 0;
}
\end{lstlisting}
\marginal{ bootloader也可以传递参数给Kernel, 原理就是bootloader向一块内存中写
入具有特定结构的数据,然后Kernel在调用时分析此内存数据,最后也会放到标准
command_line缓存中,像上面一样处理.}

 decompress_kernel （arch/arm/boot/compressed/misc.c） 调用 putstr("Uncompressing Linux..."); 向控制台打印消息。
函数printk应该也可以的。这方面没经验，希望大家补充。


\end{enumerate}


\subsubsection{printk 简介}
最常用的调试技术是监视, 在应用程序编程当中是通过在合适的地方调用 printf 来实现
. 在你调试内核代码时, 你可以通过 printk 来达到这个目的.
\begin{enumerate}
    \item printk函数中能够指定优先级，假如printk没有指定优先级，采用默认优先级
        ，DEFAULT_MESSAGE_LEVEL，其值在kernel/printk.c.
    \item  当 printk 指定的优先级小于指定的控制台优先级 console_loglevel 时，
        调试消息就显示在控制台虚拟终端。缺省的 console_loglevel 值是
        DEFAULT_CONSOLE_LOGLEVEL。
    \item 也能够使用系统调用sys_syslog或klogd -c来修改console_loglevel值。
    \item 在新版本中，也能够直接通过文档/proc/sys/kernel/printk修改
        ,这个文档包含4个整数值，前两个表示系统当前的优先级和缺省优先级。能够直接
        echo 8 > /proc/sys/kernel/printk
    \item 也能够指定显示在其他控制台，通过调用ioctl(TIOCLINUX)或shell命令setconsole来配置。
    \item 假如运行了klogd和syslogd，则printk打印到var/log/messages。
    \item dmesg 直接打印在控制台上
\end{enumerate}

\subsubsection{printk 的优先级}
一个不同是 printk 允许你根据消息的严重程度对其分类, 通过附加不同的记录级别或者
优先级在消息上. 你常常用一个宏定义来指示记录级别. 例如, KERN_INFO, 我们之前曾
在一些打印语句的前面看到过, 是消息记录级别的一种可能值. 记录宏定义扩展成一个字
串, 在编译时与消息文本连接在一起; 这就是为什么下面的在优先级和格式串之间没有逗
号的原因. 这里有 2 个 printk 命令的例子, 一个调试消息, 一个紧急消息:
\begin{lstlisting}[language=c]
printk(KERN_DEBUG "Here I am: %s:%i\n", __FILE__, __LINE__);
printk(KERN_CRIT "I'm trashed; giving up on %p\n", ptr);
\end{lstlisting}


有 8 种可能的记录字串, 在头文件 <linux/kernel.h> 里定义; 我们按照严重性递减的顺序列出它们:
\tabcaption{printk的优先级}
\begin{tabular}{|l|p{0.7\textwidth}|}\hline
KERN_EMERG & 用于紧急消息, 常常是那些崩溃前的消息.\\\hline
KERN_ALERT & 需要立刻动作的情形.\\\hline
KERN_CRIT & 严重情况, 常常与严重的硬件或者软件失效有关.\\\hline
KERN_ERR & 用来报告错误情况; 设备驱动常常使用 KERN_ERR 来报告硬件故障.\\\hline
KERN_WARNING & 有问题的情况的警告, 这些情况自己不会引起系统的严重问题.\\\hline
KERN_NOTICE & 正常情况, 但是仍然值得注意. 在这个级别一些安全相关的情况会报告.\\\hline
KERN_INFO & 信息型消息. 在这个级别, 很多驱动在启动时打印它们发现的硬件的信息.\\\hline 
KERN_DEBUG & 用作调试消息.\\\hline

\end{tabular}
每个字串( 在宏定义扩展里 )代表一个在角括号中的整数. 整数的范围从 0 到 7, 越小的数表示越大的优先级.

一条没有指定优先级的 printk 语句缺省是 DEFAULT_MESSAGE_LOGLEVEL, 在
kernel/printk.c 里指定作为一个整数. 在 2.6.10 内核中, DEFAULT_MESSAGE_LOGLEVEL
是 KERN_WARNING, 但是在过去已知是改变的.

基于记录级别, 内核可能打印消息到当前控制台, 可能是一个文本模式终端, 串口, 或者
是一台并口打印机. 如果优先级小于整型值 console_loglevel, 消息被递交给控制台,
一次一行( 除非提供一个新行结尾, 否则什么都不发送 ). 如果 klogd 和 syslogd 都在
系统中运行, 内核消息被追加到 /var/log/messages (或者另外根据你的 syslogd 配置
处理), 独立于 console_loglevel. 如果 klogd 没有运行, 你只有读 /proc/kmsg ( 用
dmsg 命令最易做到 )将消息取到用户空间. 当使用 klogd 时, 你应当记住, 它不会保存
连续的同样的行; 它只保留第一个这样的行, 随后是, 它收到的重复行数.

变量 console_loglevel 初始化成 DEFAULT_CONSOLE_LOGLEVEL, 并且可通过 sys_syslog
系统调用修改. 一种修改它的方法是在调用 klogd 时指定 -c 开关, 在 klogd 的
manpage 里有指定. 注意要改变当前值, 你必须先杀掉 klogd, 接着使用 -c 选项重启它
. 另外, 你可写一个程序来改变控制台记录级别. 你会发现这样一个程序的版本在由 O'
Reilly 提供的 FTP 站点上的 miscprogs/setlevel.c. 新的级别指定未一个整数, 在 1
和 8 之前, 包含 1 和 8. 如果它设为 1, 只有 0 级消息( KERN_EMERG )到达控制台;
如果它设为 8, 所有消息, 包括调试消息, 都显示.

也可以通过文本文件 /proc/sys/kernel/printk 读写控制台记录级别. 这个文件有 4 个
整型值: 当前记录级别, 适用没有明确记录级别的消息的缺省级别, 允许的最小记录级别
, 以及启动时缺省记录级别. 写一个单个值到这个文件就改变当前记录级别成这个值; 因
此, 例如, 你可以使所有内核消息出现在控制台, 通过简单地输入:
\begin{lstlisting}
    # echo 8 > /proc/sys/kernel/printk
\end{lstlisting}
现在应当清楚了为什么 hello.c 例子使用 KERN_ALERT 标志; 它们是要确保消息会出现在控制台上.
4.2.2. 重定向控制台消息

Linux 在控制台记录策略上允许一些灵活性, 它允许你发送消息到一个指定的虚拟控制台(如果你的控制台使用的是文本屏幕). 缺省地, 这个"控制台"是当前虚拟终端. 为了选择一个不同地虚拟终端来接收消息, 你可对任何控制台设备调用 ioctl(TIOCLINUX). 下面的程序, setconsole, 可以用来选择哪个控制台接收内核消息; 它必须由超级用户运行, 可以从 misc-progs 目录得到.

下面是全部程序. 应当使用一个参数来指定用以接收消息的控制台的编号.

\begin{lstlisting}[language=c]
int main(int argc, char **argv) {
    char bytes[2] = {11,0}; /* 11 is the TIOCLINUX cmd number */
    if (argc==2) bytes[1] = atoi(argv[1]); /* the chosen console */
    else { 
        fprintf(stderr, "%s: need a single arg\n",argv[0]); 
        exit(1);
    }
    
    if (ioctl(STDIN_FILENO, TIOCLINUX, bytes)<0) { /* use stdin */
        fprintf(stderr,"%s: ioctl(stdin, TIOCLINUX): %s\n",
                argv[0], strerror(errno));
        exit(1);
    }
    exit(0);
}
\end{lstlisting}

setconsole 使用特殊的 ioctl 命令 TIOCLINUX, 来实现特定于 linux 的功能. 为使用
TIOCLINUX, 你传递它一个指向字节数组的指针作为参数. 数组的第一个字节是一个数,
指定需要的子命令, 下面的字节是特对于子命令的. 在 setconsole 里, 使用子命令 11,
下一个字节(存于 bytes[1])指定虚拟控制台. TIOCLINUX 的完整描述在内核源码的
drivers/char/tty_io.c 里.

\subsubsection{消息是如何记录的}

printk 函数将消息写入一个 __LOG_BUF_LEN 字节长的环形缓存, 长度值从 4 KB 到 1
MB, 由配置内核时选择. 这个函数接着唤醒任何在等待消息的进程, 就是说, 任何在系统
调用中睡眠或者在读取 /proc/kmsg 的进程. 这 2 个日志引擎的接口几乎是等同的, 但
是注意, 从 /proc/kmsg 中读取是从日志缓存中消费数据, 然而 syslog 系统调用能够选
择地在返回日志数据地同时保留它给其他进程. 通常, 读取 /proc 文件容易些并且是
klogd 的缺省做法. dmesg 命令可用来查看缓存的内容, 不会冲掉它; 实际上, 这个命令
将缓存区的整个内容返回给 stdout, 不管它是否已经被读过.

在停止 klogd 后, 如果你偶尔手工读取内核消息, 你会发现 /proc 看起来象一个 FIFO,
读者阻塞在里面, 等待更多数据. 显然, 你无法以这种方式读消息, 如果 klogd 或者其
他进程已经在读同样的数据, 因为你要竞争它.

如果环形缓存填满, printk 绕回并在缓存的开头增加新数据, 覆盖掉最老的数据. 因此,
这个记录过程会丢失最老的数据. 这个问题相比于使用这样一个环形缓存的优点是可以忽
略的. 例如, 环形缓存允许系统即便没有一个日志进程也可运行, 在没有人读它的时候可
以通过覆盖旧数据浪费最少的内存. Linux 对于消息的解决方法的另一个特性是, printk
可以从任何地方调用, 甚至从一个中断处理里面, 没有限制能打印多少数据. 唯一的缺点
是可能丢失一些数据.

如果 klogd 进程在运行, 它获取内核消息并分发给 syslogd, syslogd 接着检查
/etc/syslog.conf 来找出如何处理它们. syslogd 根据一个设施和一个优先级来区分消
息; 这个设施和优先级的允许值在 <sys/syslog.h> 中定义. 内核消息由 LOG_KERN 设施
来记录, 在一个对应于 printk 使用的优先级上(例如, LOG_ERR 用于 KERN_ERR 消息).
如果 klogd 没有运行, 数据保留在环形缓存中直到有人读它或者缓存被覆盖.

如果你要避免你的系统被来自你的驱动的监视消息击垮, 你或者给 klogd 指定一个 -f (
文件) 选项来指示它保存消息到一个特定的文件, 或者定制 /etc/syslog.conf 来适应你
的要求. 但是另外一种可能性是采用粗暴的方式: 杀掉 klogd 和详细地打印消息在一个
没有用到的虚拟终端上,[13] 或者从一个没有用到的 xterm 上发出命令 cat
/proc/kmsg.

\subsubsection{打开和关闭消息} 
在驱动开发的早期, printk 非常有助于调试和测试新代码. 当你正式发行驱动时, 换句
话说, 你应当去掉, 或者至少关闭, 这些打印语句. 不幸的是, 你很可能会发现, 就在你
认为你不再需要这些消息并去掉它们时, 你要在驱动中实现一个新特性(或者有人发现了
一个 bug), 你想要至少再打开一个消息. 有几个方法来解决这 2 个问题, 全局性地打开
或关闭你地调试消息和打开或关闭单个消息.

这里我们展示一种编码 printk 调用的方法, 你可以单独或全局地打开或关闭它们; 这个
技术依靠定义一个宏, 在你想使用它时就转变成一个 printk (或者 printf)调用.

每个 printk 语句可以打开或关闭, 通过去除或添加单个字符到宏定义的名子.

所有消息可以马上关闭, 通过在编译前改变 CFLAGS 变量的值.

同一个 print 语句可以在内核代码和用户级代码中使用, 因此对于格外的消息, 驱动和
测试程序能以同样的方式被管理.

下面的代码片断实现了这些特性, 直接来自头文件 scull.h:
\begin{lstlisting}[language=c]
#undef PDEBUG /* undef it, just in case */
#ifdef SCULL_DEBUG
# ifdef __KERNEL__

/* This one if debugging is on, and kernel space */
# define PDEBUG(fmt, args...) printk( KERN_DEBUG "scull: " fmt, ## args)
# else

/* This one for user space */
# define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
# endif
#else
# define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG #define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */
\end{lstlisting}
符号 PDEBUG 定义和去定义, 取决于 SCULL_DEBUG 是否定义, 和以何种方式显示消息适
合代码运行的环境: 当它在内核中就使用内核调用 printk, 在用户空间运行就使用 libc
调用 fprintf 到标准错误输出. PDEBUGG 符号, 换句话说, 什么不作; 他可用来轻易地"
注释" print 语句, 而不用完全去掉它们.

为进一步简化过程, 添加下面的行到你的 makfile 里:
\begin{lstlisting}[language=make]
# Comment/uncomment the following line to disable/enable debugging
DEBUG = y

# Add your debugging flag (or not) to CFLAGS
ifeq ($(DEBUG),y)
 DEBFLAGS = -O -g -DSCULL_DEBUG # "-O" is needed to expand inlines
else
 DEBFLAGS = -O2
endif

CFLAGS += $(DEBFLAGS) 
\end{lstlisting}
本节中出现的宏定义依赖 gcc 对 ANSI C 预处理器的扩展, 支持带可变个数参数的宏定
义. 这个 gcc 依赖不应该是个问题, 因为无论如何内核固有的非常依赖于 gcc 特性. 另
外, makefile 依赖 GNU 版本的 make; 再一次, 内核也依赖 GNU make, 所以这个依赖不
是问题.

如果你熟悉 C 预处理器, 你可以扩展给定的定义来实现一个"调试级别"的概念, 定义不
同的级别, 安排一个整数(或者位掩码)值给每个级别, 以便决定它应当多么详细.

但是每个驱动有它自己的特性和监视需求. 好的编程技巧是在灵活性和效率之间选择最好
的平衡, 我们无法告诉你什么是最好的. 记住, 预处理器条件(连同代码中的常数表达式)
在编译时执行, 因此你必须重新编译来打开或改变消息. 一个可能的选择是使用 C 条件
句, 它在运行时执行, 因而, 能允许你在出现执行时打开或改变消息机制. 这是一个好的
特性, 但是它在每次代码执行时需要额外的处理, 这样即便消息给关闭了也会影响效率.
有时这个效率损失无法接受.

本节出现的宏定义已经证明在多种情况下是有用的, 唯一的缺点是要求在任何对它的消息
改变后重新编译.

\subsubsection{速率限制} 
如果你不小心, 你会发现自己用 printk 产生了上千条消息, 压倒了控制台并且, 可能地
, 使系统日志文件溢出. 当使用一个慢速控制台设备(例如, 一个串口), 过量的消息速率
也能拖慢系统或者只是使它不反应了. 非常难于着手于系统出错的地方, 当控制台不停地
输出数据. 因此, 你应当非常注意你打印什么, 特别在驱动的产品版本以及特别在初始化
完成后. 通常, 产品代码在正常操作时不应当打印任何东西; 打印的输出应当是指示需要
注意的异常情况.

另一方面, 你可能想发出一个日志消息, 如果你驱动的设备停止工作. 但是你应当小心不
要做过了头. 一个面对失败永远继续的傻瓜进程能产生每秒上千次的尝试; 如果你的驱动
每次都打印"my device is broken", 它可能产生大量的输出, 如果控制台设备慢就有可
能霸占 CPU -- 没有中断用来驱动控制台, 就算是一个串口或者一个行打印机.

在很多情况下, 最好的做法是设置一个标志说, "我已经抱怨过这个了", 并不打印任何后
来的消息只要这个标志设置着. 然而, 有几个理由偶尔发出一个"设备还是坏的"的提示.
内核已经提供了一个函数帮助这个情况:

int printk_ratelimit(void); 
这个函数应当在你认为打印一个可能会常常重复的消息之前调用. 如果这个函数返回非零
值, 继续打印你的消息, 否则跳过它. 这样, 典型的调用如这样:
\begin{lstlisting}[language=c]
if (printk_ratelimit())
    printk(KERN_NOTICE "The printer is still on fire\n");
\end{lstlisting}

printk_ratelimit 通过跟踪多少消息发向控制台而工作. 当输出级别超过一个限度, printk_ratelimit 开始返回 0 并使消息被扔掉.

printk_ratelimit 的行为可以通过修改 /proc/sys/kern/printk_ratelimit( 在重新使能消息前等待的秒数 ) 和 /proc/sys/kernel/printk_ratelimit_burst(限速前可接收的消息数)来定制.

\subsubsection{打印设备编号} 
偶尔地, 当从一个驱动打印消息, 你会想打印与感兴趣的硬件相关联的设备号. 打印主次
编号不是特别难, 但是, 为一致性考虑, 内核提供了一些实用的宏定义( 在
<linux/kdev_t.h> 中定义)用于这个目的: 
\begin{lstlisting}[language=c]
int print_dev_t(char *buffer, dev_t dev); 
char *format_dev_t(char *buffer, dev_t dev);
\end{lstlisting}

两个宏定义都将设备号编码进给定的缓冲区; 唯一的区别是 print_dev_t 返回打印的字
符数, 而 format_dev_t 返回缓存区; 因此, 它可以直接用作 printk 调用的参数, 但是
必须记住 printk 只有提供一个结尾的新行才会刷行. 缓冲区应当足够大以存放一个设备
号; 如果 64 位编号在以后的内核发行中明显可能, 这个缓冲区应当可能至少是 20 字节
长.

总结：

\begin{enumerate}
    \item 所有系统信息是输出到ring buffer中去的.dmesg所显示的内容也是从ring buffer中读取的. 
    \item linux系统中/etc/init.d/sysklogd会启动2个守护进程:klogd 和 syslogd 
    \item klogd是负责读取内核信息的,有2种方式: 
        \begin{itemize}
            \item syslog()系统调用(这个函数用法比较全,大家去man一下看看) 
            \item 直接的对/proc/kmsg进行读取(再这提一下,/proc/kmsg是专门输出内核信息的地方)
        \end{itemize}
    \item klogd的输出结果会传送给syslogd进行处理,syslogd会根据/etc/syslog.conf的配置把log 
信息输出到/var/log/下的不同文件中。
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{android 的命令}
在Android 目录/system/xbin 及 /system/bin下的脚本和可执行程序都在adb shell或在
串口下执行，只要console服务在运行。 /system/bin/toolbox, 如果觉得toolbox 太简
略了，不能满足开发需要， 可以考虑安装 busybox。如果不想进入 adb shell 执行，可
以在 adb shell 后面加这些命令, 如： adb shell iftop

Android 的命令主要是Android sh, toolbox \footnote{代码在system/core},
frameworks cmds 提供的工具, 以及 external 下的工程提供的。
\tabcaption{Android 常用命令}
\begin{longtable}{|p{0.2\textwidth}|p{0.8\textwidth}|}\hline
dd & 数据转储，由于没有cp，mv等命令，dd 用来复制文件，\\
    & dd if=/sdcard/anim.zip of=/data/local/bootanimation.zip
    \\\hline
log & 向 Android 的日志里打印消息， 而不会在 sh 直接显示， 要用 logcat 查看。adb shell log hello 不会回显\\\hline
echo & 向 sh 打印消息，adb shll echo hello 会回显 hello.\\\hline
iftop & 查看网络流量 \\\hline
%drpd & 查看丢包数 \\\hline
tcpdump & 查看TCP/IP传输数据 \\\hline
monkey & 是用于自动化测试，通过发送事件模拟用户交互。参见\ref{monkey}。\\\hline
netstat & 网络状态 \\\hline
netcfg &  网络配置     \\\hline
route & 查看系统路由表 \\\hline
ifconfig & 网络接口配置 \\\hline
dmesg & 打印内核调试信息到串口 \\\hline
procmem -p 1 &\\\hline
ioctl &\\\hline
input &adb shell input keyevent 82 解锁屏\\
& input text shecenon@gmail.com 在输入框中输入文本\\\hline
notify &\\\hline
sqlite3 & 启动sqlite命令行。\\\hline
su & 获取root权限, 即提示符为\#。 参见\ref{privilege}。\\\hline
sync & 把内存的内容回写到Flash，比如文件的缓冲区内容。\\\hline
test & s \footnotemark \\\hline
bar & sss \footnotemark \\\hline
\end{longtable}

\addtocounter{footnote}{-1} \footnotetext{ test 的脚注}
\stepcounter{footnote}\footnotetext{bar 的脚注} 

\subsection{权限问题}\label{privilege}
编译变体(INTERNAL_VALID_VARIANTS) user userdebug eng tests在 eng 模式下默认是
root权限;userdebug 模式下默认是普通用户权限，使用 su 或 adb root, 可以获取
root 权限。而 user 模式下获取不到 root 权限. user 模式下，如果调试需要，可以修
改out/target/product/<product>/root/default.prop的 ro .secure 和 ro.debuggable
，编译并烧写ramdisk，就有root权限了，不须提升.
\subsection{系统状态}
\subsubsection{查看进程}
\begin{lstlisting}[basicstyle=\tiny]
 #  ps -t
USER     PID   PPID  VSIZE  RSS     WCHAN    PC         NAME
root      1     0     320    180   c00d7ddc 000086cc S /init
root      2     0     0      0     c007a714 00000000 S kthreadd
root      3     2     0      0     c00691cc 00000000 S ksoftirqd/0
root      4     2     0      0     c0076d5c 00000000 S events/0
root      10    2     0      0     c0076d5c 00000000 S kblockd/0
.. .. .. 
root      71    1     676    256   c0358e94 afd0c0cc S /system/bin/debuggerd
root      72    1     1288   576   c007f154 afd0bdac S /system/bin/rild
root      73    1     86288  28056 c00d7ddc afd0b844 S zygote
media     74    1     21700  4488  ffffffff afd0b6fc S /system/bin/mediaserver
system    95    73    186148 65072 ffffffff afd0b6fc S system_server
system    96    95    186148 65072 c0088f50 afd0c738 S HeapWorker
system    97    95    186148 65072 c0088f50 afd0c738 S GC
system    98    95    186148 65072 c0071d34 afd0bfec S Signal Catcher
system    99    95    186148 65072 c0088f50 afd0c738 S Compiler
system    101   95    186148 65072 c0328e8c afd0b6fc S Binder Thread #
system    102   95    186148 65072 c0088f50 afd0c738 S SurfaceFlinger
system    103   95    186148 65072 c0094ab8 afd0b45c S DisplayEventThr
system    105   95    186148 65072 c02b5274 afd0b45c S SensorService
system    109   95    186148 65072 c00fca24 afd0c51c S ActivityManager
system    111   95    186148 65072 c0088f50 afd0c738 S ProcessStats
system    113   95    186148 65072 c00fb62c afd0b45c S FileObserver
system    116   95    186148 65072 c00fca24 afd0c51c S SyncHandlerThre
system    118   95    186148 65072 c00d7ddc afd0c59c S UEventObserver
system    122   95    186148 65072 c02c0838 afd0b6fc S AlarmManager
system    123   95    186148 65072 c00fca24 afd0c51c S WindowManager
system    124   95    186148 65072 c00fca24 afd0c51c S WindowManagerPo
system    125   95    186148 65072 c00fca24 afd0c51c S InputDispatcher
system    126   95    186148 65072 c00d7ddc afd0c59c S InputReader
system    130   95    186148 65072 c00fca24 afd0c51c S ConnectivityThr
system    142   95    186148 65072 c00fca24 afd0c51c S backup
system    145   95    186148 65072 c0088f50 afd0c738 S watchdog
system    204   95    186148 65072 c0328e8c afd0b6fc S Binder Thread #
system    144   73    104976 24608 ffffffff afd0c51c S com.android.systemui
.. .. ..
system    147   144   104976 24608 c0088f50 afd0c738 S HeapWorker
system    150   144   104976 24608 c0088f50 afd0c738 S GC
system    151   144   104976 24608 c0071d34 afd0bfec S Signal Catcher
system    154   144   104976 24608 c0088f50 afd0c738 S Compiler
system    202   144   104976 24608 c00fca24 afd0c51c S SystemUI Storag
system    330   144   104976 24608 c0328e8c afd0b6fc S Binder Thread #
app_0     152   73    290696 49116 ffffffff afd0c51c S com.cappsu.launcher
app_0     155   152   290696 49116 c0088f50 afd0c738 S HeapWorker
app_0     160   152   290696 49116 c0088f50 afd0c738 S GC
app_0     165   152   290696 49116 c0071d34 afd0bfec S Signal Catcher
app_0     167   152   290696 49116 c0088f50 afd0c738 S Compiler
app_0     173   152   290696 49116 c0328e8c afd0b6fc S Binder Thread #
app_0     193   152   290696 49116 c00fca24 afd0c51c S launcher-loader
app_0     195   152   290696 49116 c00fca24 afd0c51c S loader-category
app_0     216   152   290696 49116 c0088f50 afd0c738 S Thread-11
.. .. ..
\end{lstlisting}

 -t 选项是表示打印进程的线程，注意进程号和线程号的连续是因为Linux下线程是轻量
 级进程。

showmap

showmap 156

实际就是通过/proc/156/maps查看进程的内存映射.

 ps 362 -t
 查看362号进程

lsof

\subsubsection{分区和文件系统}
卸载分区
sudo umount /mnt



把 system 挂载为可读写，前提是有root权限， 
\begin{itemize}
    \item mount -o remount,rw  /dev/block/mtdblock0 /system
    \item adb remount
\end{itemize}

打印系统的挂载的情况
\begin{itemize}
    \item mount 
    \item /proc/mounts。
\end{itemize}

toolbox 提供了 \emph{df} 命令查看分区情况，如果有busybot可以使用 busybox df -a 查看系统的存储情况：
\tabcaption{proc 文件系统与分区相关的文件}
\begin{itemize}
    \item /proc/mounts 
    \item /proc/filesystems
    \item /proc/partitions
\end{itemize}
\subsubsection{查看/设置系统属性} 
build/core/Makefile
\begin{lstlisting}
INSTALLED_DEFAULT_PROP_TARGET := $(TARGET_ROOT_OUT)/default.prop
.. .. ..
$(INSTALLED_DEFAULT_PROP_TARGET):
        .. .. ..
	$(hide) $(foreach line,$(ADDITIONAL_DEFAULT_PROPERTIES), \
		echo "$(line)" >> $@;)

.. .. ..
INSTALLED_BUILD_PROP_TARGET := $(TARGET_OUT)/build.prop
BUILDINFO_SH := build/tools/buildinfo.sh 
$(INSTALLED_BUILD_PROP_TARGET): $(BUILDINFO_SH) $(INTERNAL_BUILD_ID_MAKEFILE) 
                .. .. ..
                bash $(BUILDINFO_SH) > $@
                .. .. ..
\end{lstlisting}

\begin{multicols}{2}
\begin{lstlisting}[basicstyle=\tiny,language=]
#getprop
[ro.secure]: [0]
[ro.allow.mock.location]: [1]
[ro.debuggable]: [1]
[persist.service.adb.enable]: [1]
[ro.kernel.qemu]: [1]
[ro.kernel.console]: [ttyS0]
[ro.kernel.android.checkjni]: [1]
[ro.kernel.android.bootanim]: [0]
[ro.kernel.android.qemud]: [ttyS1]
[ro.kernel.android.ndns]: [2]
[ro.factorytest]: [0]
[ro.serialno]: []
[ro.bootmode]: [unknown]
[ro.baseband]: [unknown]
[ro.carrier]: [unknown]
[ro.bootloader]: [unknown]
[ro.hardware]: [goldfish]
[ro.revision]: [0]
[ro.build.id]: [MASTER]
[ro.build.display.id]: [generic-eng 2.2.1 MASTER eng.leo.20101026.101159 test-keys]
[ro.build.version.incremental]: [eng.leo.20101026.101159]
[ro.build.version.sdk]: [8]
[ro.build.version.codename]: [REL]
[ro.build.version.release]: [2.2.1]
[ro.build.date]: [`2010年 10月 26日 星期二 10:13:14 CST`]
[ro.build.date.utc]: [1288059194]
[ro.build.type]: [eng]
[ro.build.user]: [leo]
[ro.build.host]: [leo-desktop]
[ro.build.tags]: [test-keys]
[ro.product.model]: [generic]
[ro.product.brand]: [generic]
[ro.product.name]: [generic]
[ro.product.device]: [generic]
[ro.product.board]: []
[ro.product.cpu.abi]: [armeabi]
[ro.product.manufacturer]: [unknown]
[ro.product.locale.language]: [mdpi]
[ro.product.locale.region]: []
[ro.wifi.channels]: []
[ro.board.platform]: []
[ro.build.product]: [generic]
[ro.build.description]: [generic-eng 2.2.1 MASTER eng.leo.20101026.101159 test-keys]
[ro.build.fingerprint]: [generic/generic/generic/:2.2.1/MASTER/eng.leo.20101026.101159:eng/test-keys]
[rild.libpath]: [/system/lib/libreference-ril.so]
[rild.libargs]: [-d /dev/ttyS0]
[ro.config.notification_sound]: [OnTheHunt.ogg]
[ro.config.alarm_alert]: [Alarm_Classic.ogg]
[media.stagefright.enable-player]: [true]
[media.stagefright.enable-meta]: [true]
[media.stagefright.enable-scan]: [true]
[media.stagefright.enable-http]: [true]
[ro.setupwizard.mode]: [OPTIONAL]
[xmpp.auto-presence]: [true]
[ro.config.nocheckin]: [yes]
[net.bt.name]: [Android]
[net.change]: [net.dnschange]
[dalvik.vm.stack-trace-file]: [/data/anr/traces.txt]
[persist.sys.timezone]: [Asia/Shanghai]
[persist.sys.language]: [en]
[persist.sys.country]: [US]
[persist.sys.localevar]: []
[ro.FOREGROUND_APP_ADJ]: [0]
[ro.VISIBLE_APP_ADJ]: [1]
[ro.SECONDARY_SERVER_ADJ]: [2]
[ro.BACKUP_APP_ADJ]: [2]
[ro.HOME_APP_ADJ]: [4]
[ro.HIDDEN_APP_MIN_ADJ]: [7]
[ro.CONTENT_PROVIDER_ADJ]: [14]
[ro.EMPTY_APP_ADJ]: [15]
[ro.FOREGROUND_APP_MEM]: [1536]
[ro.VISIBLE_APP_MEM]: [2048]
[ro.SECONDARY_SERVER_MEM]: [4096]
[ro.BACKUP_APP_MEM]: [4096]
[ro.HOME_APP_MEM]: [4096]
[ro.HIDDEN_APP_MEM]: [5120]
[ro.CONTENT_PROVIDER_MEM]: [5632]
[ro.EMPTY_APP_MEM]: [6144]
[net.tcp.buffersize.default]: [4096,87380,110208,4096,16384,110208]
[net.tcp.buffersize.wifi]: [4095,87380,110208,4096,16384,110208]
[net.tcp.buffersize.umts]: [4094,87380,110208,4096,16384,110208]
[net.tcp.buffersize.edge]: [4093,26280,35040,4096,16384,35040]
[net.tcp.buffersize.gprs]: [4092,8760,11680,4096,8760,11680]
[init.svc.console]: [running]
[init.svc.servicemanager]: [running]
[init.svc.vold]: [running]
[init.svc.netd]: [running]
[init.svc.debuggerd]: [running]
[init.svc.ril-daemon]: [running]
[init.svc.zygote]: [running]
[init.svc.media]: [running]
[init.svc.installd]: [running]
[init.svc.keystore]: [running]
[init.svc.goldfish-setup]: [running]
[init.svc.qemud]: [running]
[init.svc.goldfish-logcat]: [stopped]
[ARGH]: [ARGH]
[net.eth0.dns1]: [10.0.2.3]
[net.gprs.local-ip]: [10.0.2.15] 
[ro.radio.use-ppp]: [no]
[status.battery.state]: [Slow]
[status.battery.level]: [5]
[status.battery.level_raw]: [50]
[status.battery.level_scale]: [9]
[ro.com.google.locationfeatures]: [1]
[init.svc.adbd]: [running] 
[net.eth0.dns2]: [10.0.2.4]
[debug.sf.nobootanimation]: [1]
[qemu.sf.lcd_density]: [120]
[dalvik.vm.heapsize]: [16m]
[init.svc.bootanim]: [stopped]
[hw.keyboards.65536.devname]: [qwerty2]
[net.hostname]: [android_2c4e97329e91946e]
[dev.bootcomplete]: [1]
[adb.connected]: [1]
[gsm.version.ril-impl]: [android reference-ril 1.0]
[gsm.sim.operator.numeric]: [310260]
[gsm.sim.operator.alpha]: [Android]
[gsm.sim.operator.iso-country]: [us]
[gsm.sim.state]: [READY]
[gsm.current.phone-type]: [1]
[gsm.nitz.time]: [1291603103518]
[gsm.network.type]: [UMTS]
[gsm.operator.alpha]: [Android]
[gsm.operator.numeric]: [310260]
[gsm.operator.iso-country]: [us]
[gsm.operator.isroaming]: [false]
[sys.settings_secure_version]: [1]
[net.gprs.http-proxy]: []
[gsm.defaultpdpcontext.active]: [true]
[net.dns1]: [10.0.2.3]
[net.dns2]: [10.0.2.4]
[net.dnschange]: [1]
[ro.runtime.firstboot]: [1291603112272]
\end{lstlisting}
\end{multicols}

ro.*.* 表示只读的。 


init.svc.* 是表示 init 进程启动的服务\label{initsvcstat}状态。
\subsubsection{转储}
 转储的含义是把某些东西某一时刻的状态通过一定方式呈现给用户，通常的做法是把某
 个系统组件的某个时刻状态打印出来，比如 logcat 的 -d （dump），就是把 Android
 Log 的内容打印出来，并退出，而不会一直等待Log的更新。
Android 系统的转储有两个命令： dumpsys 和 dumpstate。dumpstate 主要是转储
Android 系统运行状态，包括C++层的服务， Java层的Activity，Service 的 dumpstat
函数（方法）都会通过 Binder 通讯方式被调用 ,
而 dumpsys 打印linux /proc 有关Linux系统状态的几个文件，并调用dumpstat打印 Android的状态.


\subsection{用户程序}
\subsubsection{安装、卸载应用}
Pm是应用软件包管理器， 命令 pm list packages 可以列出系统中安装的包。
\begin{lstlisting}
     pm install [-l] [-r] [-t] [-i INSTALLER_PACKAGE_NAME] [-s] [-f] PATH 
     pm uninstall [-k] PACKAGE
 \end{lstlisting}
adb install / adb  uninstall 就是通过这个命令来实现的吧！

安装apk常见问题及解决：
\begin{enumerate}
    \item Failure [INSTALL_FAILED_OLDER_SDK]

        adb install -r out/target/product/generic/data/app/ApiDemosTests.apk
        原因编译apk时指定SDK版本要比运行时的SDK高。
        \begin{verbatim}
        1. 打开源码目录下的AndroidManifest.xml文件，然后注释掉或者删除掉这行：
             <uses-sdk android:minSdkVersion="4" />
        再重新编译，就能安装到低版本的系统上运行了

        2 /build/core/version_defaults.mk文件中这一段
        ifeq "" "$(DEFAULT_APP_TARGET_SDK)"
          # This is the default minSdkVersion and targetSdkVersion to use for
          # all .apks created by the build system.  It can be overridden by explicitly
          # setting these in the .apk's AndroidManifest.xml.  It is either the code
          # name of the development build or, if this is a release build, the official
          # SDK version of this release.
          ifeq "REL" "$(PLATFORM_VERSION_CODENAME)"
            DEFAULT_APP_TARGET_SDK := $(PLATFORM_SDK_VERSION)
          else
            DEFAULT_APP_TARGET_SDK := $(PLATFORM_VERSION_CODENAME)
          endif
        endif

        将DEFAULT_APP_TARGET_SDK直接赋值相应的API等级即可。

        我的做法是 ，修改了development/samples/ApiDemos/Android.mk

        #LOCAL_SDK_VERSION := current
        DEFAULT_APP_TARGET_SDK=7

        在SMDK6410 开发板开发时，遇到这个问题，情况是 SD 卡的 /system 目录是使
        用别人的，他的 SDK 版本跟我的编译的不一样。 我要修改了 Android
        framework ，并编译。但是，更新 SD 卡中的镜像文件时，脚本中的命令出错了
        ， 把 SD中的分区挂载到当前目录的tmp子目录下，但拷贝命令的目的目录确是
        /tmp。所以，SD 卡的镜像实际没更新。
        API level 跟 build/core/version_defaults.mk:56:  PLATFORM_SDK_VERSION
        相关。并反应在build/tools/buildinfo.sh    ro.build.version.sdk 的属性。
        \end{verbatim}
    \item INSTALL_FAILED_MISSING_FEATURE

        \begin{verbatim}
            aapt r  out/target/product/generic/system/app/Launcher2.apk resources.arsc
            aapt list -v out/target/product/generic/system/app/Launcher2.apk  
            列出压缩包里的文件以及文件信息、压缩状况

            更换 apk 包的文件。
            ~$ aapt r Calculator.apk res/drawable-hdpi/advanced.png
            ~$ mv ic_bullet_key_permission.png  res/drawable-hdpi/advanced.png 
            ~$ aapt a Calculator.apk res/drawable-hdpi/advanced.png

            aapt dump xmltree Calculator.apk AndroidManifest.xml
        \end{verbatim}
\end{enumerate} 

\subsubsection{命令行启动应用}
\begin{verbatim}

adb shell am instrument com.two.camera.test/android.test.InstrumentationTestRunner
Android命令行启动程序的方法为
am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称} 
启动的方法可以从每个应用的AndroidManifest.xml的文件中得到

Camera（照相机）的Android命令行启动程序方法为：
am start -n com.android.camera/com.android.camera.Camera 
Browser（浏览器）的Android命令行启动程序方法为：
am start -n com.android.browser/com.android.browser.BrowserActivity 

mmm frameworks/base/tests/AndroidTests
adb install -r -f out/target/product/passion/data/app/AndroidTests.apk
adb shell am instrument -w -e class com.android.unit_tests.PackageManagerTests com.android.unit_tests/android.test.InstrumentationTestRunner

am start -a android.intent.action.CALL -d tel:88888888
am start -a android.intent.action.VIEW -d http://3g.163.com 
am start -n com.android.browser/.BrowserActivity

usage: am [subcommand] [options] 

    start an Activity: am start [-D] [-W] <INTENT> 
        -D: enable debugging 
        -W: wait for launch to complete 

    start a Service: am startservice <INTENT> 

    send a broadcast Intent: am broadcast <INTENT> 

    start an Instrumentation: am instrument [flags] <COMPONENT> 
        -r: print raw results (otherwise decode REPORT_KEY_STREAMRESULT) 
        -e <NAME> <VALUE>: set argument <NAME> to <VALUE> 
        -p <FILE>: write profiling data to <FILE> 
        -w: wait for instrumentation to finish before returning 
 
    start profiling: am profile <PROCESS> start <FILE> 
    stop profiling: am profile <PROCESS> stop 

    <INTENT> specifications include these flags: 
        [-a <ACTION>] [-d <DATA_URI>] [-t <MIME_TYPE>] 
        [-c <CATEGORY> [-c <CATEGORY>] ...] 
        [-e|--es <EXTRA_KEY> <EXTRA_STRING_VALUE> ...] 
        [--esn <EXTRA_KEY> ...] 
        [--ez <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE> ...] 
        [-e|--ei <EXTRA_KEY> <EXTRA_INT_VALUE> ...] 
        [-n <COMPONENT>] [-f <FLAGS>] 
        [--grant-read-uri-permission] [--grant-write-uri-permission] 
        [--debug-log-resolution] 
        [--activity-brought-to-front] [--activity-clear-top] 
        [--activity-clear-when-task-reset] [--activity-exclude-from-recents] 
        [--activity-launched-from-history] [--activity-multiple-task] 
        [--activity-no-animation] [--activity-no-history] 
        [--activity-no-user-action] [--activity-previous-is-top] 
        [--activity-reorder-to-front] [--activity-reset-task-if-needed] 
        [--activity-single-top] 
        [--receiver-registered-only] [--receiver-replace-pending] 
        [<URI>] 
    \end{verbatim}

am 其实是一个脚本，代码放在 frameworks/base/cmds/am/am。类似的，还有input， pm， ime，都在 cmds下的相应目录下。

\subsubsection{服务}
\begin{list}{$\bullet$}{\listparam}
\item 列出服务 service
\item 启动服务 start\\
    toolbox\cite{toolbox} 提供, 实际上是通过 init 的 ctl.start 。
    start 后面没跟服务名，则默认启动 runtime ,  zygote
    start zygote  等价于  setprop  ctl.start zygote
    stop console 是启动控制台， adb shell 即 Android sh \cite{sh} 依赖 console.
\item 关闭服务 stop
    toolbox 提供, 实际上是通过 init 的 ctl.stop 。
    不指定服务名, 就stop runtime 及 zygote 这两个服务， 否则关闭指定的服务
    stop zygote 等价于 setprop ctl.stop zygote
start console 关闭控制台
\end{list}
ActivityManagerService.java is the high-level process management.  Not every interaction between two application goes through here though; they can directly talk with each other through services and content providers, in which case the only common hook is in the kernel.

/data/system/packages.xml is the information about the installed packages.  It is read and written by PackageManagerService.xml.  It is far more than just permissions.
service 命令（frameworks/base/cmds/service）可以打印系统的服务, 但是这是只能打
印 Android 的服务，即 system_server 里的服务，而其他的比如 init 启动的服务，其
状态通过系统属性查询\ref{initsvcstat}：

\begin{lstlisting}[numbers=none]
Found 49 services:
0       phone: [com.android.internal.telephony.ITelephony]
1       iphonesubinfo: [com.android.internal.telephony.IPhoneSubInfo]
2       simphonebook: [com.android.internal.telephony.IIccPhoneBook]
3       isms: [com.android.internal.telephony.ISms]
4       appwidget: [com.android.internal.appwidget.IAppWidgetService]
5       backup: [android.backup.IBackupManager]
6       audio: [android.media.IAudioService]
7       wallpaper: [android.app.IWallpaperManager]
8       checkin: [android.os.ICheckinService]
9       search: [android.app.ISearchManager]
10      location: [android.location.ILocationManager]
11      devicestoragemonitor: []
.. .. ..
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{调试}
\subsection{gdb}
 监听端口
\begin{lstlisting}[language=bash]
$adb shell
#cd /data/example
# gdbserver 10.0.2.2:1234  ./hello     
Process ./hello created; pid = 274 
Listening on port 1234 
\end{lstlisting}

10.0.2.2是模拟器的默认IP地址，源码 system/core/rootdir/etc/init.goldfish.sh  和模拟器中脚本/system/etc/init.goldfish.sh中设置 的。

 数据转发
打开另一个terminal，telnet Android Console
\lstinline{$telnet localhost  5554}
在 Android 控制台，输入：
\lstinline{redir add tcp:1234:1234}

这条命令表示将所有到localhost:1234的数据转发到模拟器的1234端口。
主机(host)远程调试
\begin{lstlisting}[language=bash]
$arm-none-linux-gnueabi-gdb hello
(gdb) set solib-absolute-prefix /out/target/product/xxxxxx/symbols/system/lib/
(gdb) set solib-search-path out/target/product/xxxxxx/symbols/system/lib/
(gdb) target remote localhost:1234
\end{lstlisting}


\subsection{jdb}
\subsubsection{建立 Android 的 JDB 调试环境}
\begin{enumerate}
\item [0]先要确保adb工作正常。
\item 先用adb jdwp列出支持JDPW的进程ID。
    \begin{lstlisting}
        835
        876
        873
        879
    \end{lstlisting}
\item  用adb shell ps查看进程的信息。
    \begin{lstlisting}
system 835 793 208564 29768 ffffffff afe0c57c S system_server
radio 873 793 112816 21252 ffffffff afe0d674 S com.android.phone
app_8 876 793 98044 17336 ffffffff afe0d674 S android.process.media
app_7 879 793 123780 28452 ffffffff afe0d674 S android.process.acore
\end{lstlisting}
\item  确定要调试的进程ID之后，建立网络数据转发关系。

假设这里要调试进程873，即电话进程。
{\center adb forward tcp:9000 jdwp:873}{\label{forward}}

\item 设置jdb源代码路径

    这里设置了android系统的Java路径，如果调试应用程序，要追加应用的代码路径。
    \begin{lstlisting}[language=bash]
export ANDROID=~/android
export ANDROID_SRC_PATH=$ANDROID/frameworks/base/opengl/java:$ANDROID/frameworks/base/awt/java:$ANDROID/frameworks/base/core/java:$ANDROID/frameworks/base/location/java:$ANDROID/frameworks/base/sax/java:$ANDROID/frameworks/base/graphics/java:$ANDROID/frameworks/base/telephony/java:$ANDROID/frameworks/base/services/java:$ANDROID/frameworks/base/media/java:$ANDROID/frameworks/base/wifi/java:$ANDROID/frameworks/base/im/java:$ANDROID/dalvik/libcore/suncompat/src/main/java:$ANDROID/dalvik/libcore/nio_char/src/main/java:$ANDROID/dalvik/libcore/nio_char/src/main/java/java:$ANDROID/dalvik/libcore/security-kernel/src/main/java:$ANDROID/dalvik/libcore/security-kernel/src/main/java/java:$ANDROID/dalvik/libcore/security/src/main/java:$ANDROID/dalvik/libcore/security/src/main/java/java:$ANDROID/dalvik/libcore/archive/src/main/java:$ANDROID/dalvik/libcore/archive/src/main/java/java:$ANDROID/dalvik/libcore/awt-kernel/src/main/java:$ANDROID/dalvik/libcore/awt-kernel/src/main/java/java:$ANDROID/dalvik/libcore/luni/src/main/java:$ANDROID/dalvik/libcore/luni/src/main/java/java:$ANDROID/dalvik/libcore/math/src/main/java:$ANDROID/dalvik/libcore/math/src/main/java/java:$ANDROID/dalvik/libcore/x-net/src/main/java:$ANDROID/dalvik/libcore/openssl/src/main/java:$ANDROID/dalvik/libcore/dalvik/src/main/java:$ANDROID/dalvik/libcore/auth/src/main/java:$ANDROID/dalvik/libcore/concurrent/src/main/java:$ANDROID/dalvik/libcore/concurrent/src/main/java/java:$ANDROID/dalvik/libcore/sql/src/main/java:$ANDROID/dalvik/libcore/sql/src/main/java/java:$ANDROID/dalvik/libcore/prefs/src/main/java:$ANDROID/dalvik/libcore/prefs/src/main/java/java:$ANDROID/dalvik/libcore/xml/src/main/java:$ANDROID/dalvik/libcore/text/src/main/java:$ANDROID/dalvik/libcore/text/src/main/java/java:$ANDROID/dalvik/libcore/luni-kernel/src/main/java:$ANDROID/dalvik/libcore/luni-kernel/src/main/java/java:$ANDROID/dalvik/libcore/regex/src/main/java:$ANDROID/dalvik/libcore/regex/src/main/java/java:$ANDROID/dalvik/libcore/nio/src/main/java:$ANDROID/dalvik/libcore/nio/src/main/java/java:$ANDROID/dalvik/libcore/json/src/main/java:$ANDROID/dalvik/libcore/crypto/src/main/java:$ANDROID/dalvik/libcore/icu/src/main/java:$ANDROID/dalvik/libcore/annotation/src/main/java:$ANDROID/dalvik/libcore/annotation/src/main/java/java:$ANDROID/dalvik/libcore/junit/src/main/java:$ANDROID/dalvik/libcore/logging/src/main/java:$ANDROID/dalvik/libcore/logging/src/main/java/java:$ANDROID/dalvik/libcore-disabled/instrument/src/main/java:$ANDROID/dalvik/libcore-disabled/instrument/src/main/java/java:$ANDROID/dalvik/libcore-disabled/sound/src/main/java
\end{lstlisting}
 \item 启动jdb
     {\center jdb -sourcepath \$ANDROID_SRC_PATH -attach localhost:9000}
     这里的端口号9000，是由前面的tcp:9000\ref{forward}决定。
\end{enumerate}




\subsubsection{jdb/jdbshell基本调试技巧}
man jdb, jdb -help, 或者 输入jdb回车，在jdb提示符下输入help或？都可以得到在线帮助。
jdbshell兼容所有jdb命令，只是另外加了些命令缩写、记录历史、命令自动补全和命令行编辑等功能。

\begin{description}
    \item [用threads查询所有线程]
        命令：threads

        结果显示示例：
        \begin{lstlisting}[language=]
        组 system：
        (java.lang.Thread)0xc14360d1e8 <7> Signal Catcher 条件正在等待
        (java.lang.Thread)0xc142850040 <5> HeapWorker 条件正在等待
        组 main：
        (java.lang.Thread)0xc140018e50 <3> main 条件正在等待
        (java.lang.Thread)0xc143767c78 <59> Binder Thread #16 正在运行
        (java.lang.Thread)0xc143744d48 <57> Binder Thread #15 正在运行
        (java.lang.Thread)0xc143757458 <51> Binder Thread #14 正在运行
        (java.lang.Thread)0xc14374ab88 <55> Binder Thread #13 正在运行
        (java.lang.Thread)0xc14376d698 <53> Binder Thread #12 正在运行
        (java.lang.Thread)0xc143615478 <45> Binder Thread #11 正在运行
        (java.lang.Thread)0xc1437317b0 <49> Binder Thread #10 正在运行
        (java.lang.Thread)0xc1436e8c38 <47> Binder Thread #9 正在运行
        (java.lang.Thread)0xc14374eb50 <43> Binder Thread #8 正在运行
        (java.lang.Thread)0xc1437000e0 <41> Binder Thread #7 正在运行
        (android.os.HandlerThread)0xc1436dd9d0 <37> ContactsAsyncWorker 条件正在等待
        (java.lang.Thread)0xc143681fb8 <35> Binder Thread #6 正在运行
        (java.lang.Thread)0xc143681ef8 <33> Binder Thread #5 正在运行
        (java.lang.Thread)0xc143659170 <31> Stk App Service 条件正在等待
        (java.lang.Thread)0xc14368bc88 <29> Binder Thread #4 正在运行
        (java.lang.Thread)0xc14368ad00 <27> Binder Thread #3 正在运行
        (android.os.HandlerThread)0xc1436597a0 <25> AsyncQueryWorker 条件正在等待
        (android.os.HandlerThread)0xc143656c00 <23> Stk Icon Loader 条件正在等待
        (android.os.HandlerThread)0xc143656580 <21> RilMessageDecoder 条件正在等待
        (android.os.HandlerThread)0xc1436560a0 <19> Stk Telephony service 条件正在等待
        (java.lang.Thread)0xc143643c70 <17> RILReceiver 正在运行
        (android.os.HandlerThread)0xc143641858 <15> RILSender 条件正在等待
        (java.lang.Thread)0xc14360ee08 <13> Binder Thread #2 正在运行
        (java.lang.Thread)0xc14360df90 <11> Binder Thread #1 正在运行
        \end{lstlisting}

    \item [选择你感兴趣的线程]
        命令：thread 0xc1436dd9d0

        结果显示示例：
        \verb|<37> ContactsAsyncWorker[1]|

        和gdb不同的是，这里使用线程的ID，而不是线程的序号。这个问题让我折腾了好久，问
        了好几个做JAVA的朋友，原来他们都不用jdb。

    \item [暂停线程。]
        命令：suspend 0xc1436dd9d0

    \item [显示调用堆栈。]
        命令：wherei

        结果显示示例：
        \begin{verbatim}
        [1] java.lang.Object.wait (本机方法)
        [2] java.lang.Object.wait (Object.java：288), pc = 3
        [3] android.os.MessageQueue.next (MessageQueue.java：148), pc = 153
        [4] android.os.Looper.loop (Looper.java：110), pc = 8
        [5] android.os.HandlerThread.run (HandlerThread.java：60), pc = 28
        \end{verbatim}

    \item [切换调用堆栈的frame:]
        up [n 帧] – 向上移动线程的堆栈\\
        down [n 帧] – 向下移动线程的堆栈

        和gdb不同的时，这里指定的是要切换的frame与当前frame的偏移，而不是frame的索引。

        结果显示示例：
        \begin{verbatim}
        <37> ContactsAsyncWorker[1] up
        <37> ContactsAsyncWorker[2]
        \end{verbatim}

    \item [设置断点] 
        stop at <类>:<行号>\\
        stop in <类>.<方法名>[(参数类型,...)]

        结果显示示例：
        \begin{verbatim}
        > stop at com.android.phone.SimContacts$ImportAllThread:124
        设置 断点 com.android.phone.SimContacts$ImportAllThread:124
        \end{verbatim}

    \item [显示某个类的信息。有时要在嵌套类里设置断点，这个命令可能有帮助。]
        class <类 ID> – 显示已命名的类的详细信息

        结果显示示例：
        \begin{verbatim}
        >class com.android.phone.SimContacts
        类：com.android.phone.SimContacts
        扩展： com.android.phone.ADNList
        嵌套： com.android.phone.SimContacts$ImportAllThread
        \end{verbatim}

    \item [继续运行]
        step – 执行当前行\\
        step up – 执行到当前方法返回到其调用程序\\
        stepi – 执行当前指令\\
        next – 跳过一行（跨过调用）\\
        cont – 从断点处继续执行

    \item [清除断点]
        clear <类 ID>.<方法>[(参数类型,...)]     – 清除方法中的断点\\
        clear <类 ID>:<行>                       – 清除行中的断点\\
        clear – 列出断点

    \item [查看源代码] 
        list [line number|method]

    \item [jdbshell命令缩写(command alias)]
            \begin{tabular}{|lcr|}\hline
                c &->& cont\\\hline
                l &->& list\\\hline
                n &->& next\\\hline
                r &->& run\\\hline
                s &->& step\\\hline
                si &->& stepi\\\hline
                f &->& step up\\\hline
                bt &->& wherei\\\hline
            \end{tabular}

\end{description}

\subsubsection{jdb debug example}
\begin{verbatim}
xml$ jdb -classpath . StAXTest
正在初始化 jdb...
> step
使用 "run" 命令启动 VM 之后，命令 "step" 才有效
> run
运行 StAXTest
设置 未捕捉到 java.lang.Throwable
设置延迟的 未捕捉到 java.lang.Throwable
> 
VM 已启动： Using http://www.w3.org

> locals
未指定默认线程：请先使用 "thread" 命令。
> thread
未指定线程号。
> threads
组 system：
  (java.lang.ref.Reference$ReferenceHandler)0x128 Reference Handler 条件正在等待
  (java.lang.ref.Finalizer$FinalizerThread)0x127  Finalizer         条件正在等待
  (java.lang.Thread)0x126                         Signal Dispatcher 正在运行
组 main：
  (java.lang.Thread)0x1                           main              正在运行
> locals 0x1
未指定默认线程：请先使用 "thread" 命令。
> thread 0x1
main[1] 
main[1] locals
当前线程未暂停。
main[1] stop
未设置断点。
main[1] suspend
所有线程已暂停。
main[1] locals
局部变量信息不可用。使用 -g 编译以生成变量信息
main[1] list
当前方法是本机方法
main[1] exit



xml$ jdb -classpath . StAXTest
正在初始化 jdb...
> stop at StAXTest:34
正在延迟 断点 StAXTest:34。
将在装入类之后对其进行设置。
> run
运行 StAXTest
设置 未捕捉到 java.lang.Throwable
设置延迟的 未捕捉到 java.lang.Throwable
> 
VM 已启动： 无法设置延迟的 断点 StAXTest:34： StAXTest 中的第 34 行没有代码

由于延迟的断点错误而停止。
当前调用堆栈中没有帧

main[1] stop
断点集：
    断点 StAXTest:34
main[1] exit
Using http://www.w3.org
致命错误：
读取子 java 解释程序的输出失败。


xml$ jdb -classpath . StAXTest
正在初始化 jdb...
> list             
使用 "run" 命令启动 VM 之后，命令 "list" 才有效
> stop at StAXTest:21
正在延迟 断点 StAXTest:21。
将在装入类之后对其进行设置。
> run
运行 StAXTest
设置 未捕捉到 java.lang.Throwable
设置延迟的 未捕捉到 java.lang.Throwable
> 
VM 已启动： 设置延迟的 断点 StAXTest:21
Using http://www.w3.org

断点命中： "thread=main", StAXTest.main(), line=21 bci=67
21             while(parser.hasNext()) {

main[1] next
> 
已完成步骤： "thread=main", StAXTest.main(), line=22 bci=77
22                 int event = parser.next();

main[1] next
> cont
未暂停任何对象。
> 
已完成步骤： "thread=main", StAXTest.main(), line=23 bci=86
23                 if (event == XMLStreamConstants.START_ELEMENT) {
\end{verbatim}


\subsubsection{jdb 的另一个版本}
JDWP用于在java程序层面的调试,当然也可以在eclipse中使用,或利用ddms调试。
\begin{verbatim}
 在某一终端运行虚拟机
$ adb forward tcp:8000 tcp:8000
$ adb shell
$ dalvikvm -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y -cp /sdcard/foo.jar Foo
此时挂起等待调试
 在另一终端开启调试
$ jdb -attach localhost:8000
[jdb提示符] run
此时程序继续运行
 jdb常用命令
[jdb 提示符] threads 看当前所有线程
[jdb 提示符] trace methods 0x12aac5a00  跟踪线程号为0x12aac5a00的线程(线程号从threads得到)
[jdb 提示符] next/step 下一步
[jdb 提示符] 40 next  执行40次next


jdwp(java debug wire protocol)及原理
1) 虚拟机（设备端）在启动时加载了Agent JDWP 从而具备了调试功能。在调试器端（PC端）通过JDWP协议与设备连接，通过发送命令来获取的状态和控制Java程序的执行。JDWP 是通过命令（command）和回复（reply）进行通信的。
2) JDK 中调试工具 jdb 就是一个调试器，DDMS也提供调试器与设备相连。
3) dalvik为JDWP提供了两种连接方式：tcp方式和adb方式，tcp方式可以手工指定端口，adb方式自动设定为8700端口，通常使用DDMS调试就是通过adb方式


Android 有个工具 jdwpspy ，以后研究如何使用。

\end{verbatim}


\subsection{debuggerd}
debugerd  在 C/C++ 崩溃时打印上下文场景, 可以手工调试:
\begin{lstlisting} 
prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-addr2line -e out/target/product/m970/symbols/system/lib/libandroid_runtime.so 00045b94
\end{lstlisting}

更方便的是 Android 提供的 adbs 脚本, 如下使用:
\begin{lstlisting} 
$ export ANDROID_PRODUCT_OUT=~/samsung/E9/out/target/product/e9/
$./build/tools/adbs logcat 
\end{lstlisting}

这个是C/C++库出问题时输出的消息，由服务debuggerd 打印的，好像与JIT 相关。
Debuggerd的实现在 system/core/debuggerd/debuggerd.c
，system/core/rootdir/init.rc中定义了此服务，所以是由init进程启动的。
dalvik/tools/gdbjithelper/README.txt
给出了在遇到这类问题如何调试，代码可以阅读文件
dalvik/tools/gdbjithelper/gdbjithelper.c等。

\begin{lstlisting}[caption=debugerd的输出, basicstyle=\tiny]
I/DEBUG   (  371): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** 
I/DEBUG   (  371): Build fingerprint: 'generic/sdk/generic/:2.2/FRF42/36942:eng/test-keys' 
I/DEBUG   (  371): pid: 377, tid: 388  >>> com.android.browser <<< 
I/DEBUG   (  371): signal 11 (SIGSEGV), fault addr fbf5d5b3 
I/DEBUG   (  371):  r0 817be6e0  r1 810e5378  r2 810e5373  r3 006f6cfc 
I/DEBUG   (  371):  r4 817be6e4  r5 0000000b  r6 00000004  r7 00000000 
I/DEBUG   (  371):  r8 45464d80  r9 428c3ee0  10 428c3ec8  fp 0025bf30 
I/DEBUG   (  371):  ip 810000dc  sp 45464180  lr 810e5379  pc b0001330  cpsr 80000010 
I/DEBUG   (  371):          #00  pc b0001330  /system/bin/linker 
I/DEBUG   (  371):          #01  pc 000e5376  /data/data/com.adobe.flashplayer/lib/libflashplayer.so 
I/DEBUG   (  371):          #02  pc 000e5376  /data/data/com.adobe.flashplayer/lib/libflashplayer.so 
... ... 
I/DEBUG   (  371): code around pc: 
I/DEBUG   (  371): b0001310 2b60688b 4a23d112 4e214b24 18e218a0 
I/DEBUG   (  371): b0001320 4c2319a5 33201c2b 68099400 21c09101 
I/DEBUG   (  371): b0001330 97020089 f0012500 e02afe5f 0072268c 
I/DEBUG   (  371): b0001340 1c0d435a 18ae350c 3301604e 608b36a4 
I/DEBUG   (  371): b0001350 4d126030 0052228c 68451960 36a41c2e 
I/DEBUG   (  371): 
I/DEBUG   (  371): code around lr: 
I/DEBUG   (  371): 810e5358 f85ee00c 68513003 47986892 bd00b003 
I/DEBUG   (  371): 810e5368 eb006810 e7f60061 bf004b56 f8dfa100 
I/DEBUG   (  371): 810e5378 b09cc158 a91c185b f8534a54 f8df000c 
I/DEBUG   (  371): 810e5388 189ac150 0d70f841 e882c903 a91c0003 
I/DEBUG   (  371): 810e5398 000cf853 0c10f102 0d68f841 e88cc903 
I/DEBUG   (  371): 
I/DEBUG   (  371): stack: 
I/DEBUG   (  371):     45464140  81002180  /data/data/com.adobe.flashplayer/lib/libflashplayer.so 
I/DEBUG   (  371):     45464144  b0001599  /system/bin/linker 
... ... 
\end{lstlisting}

\subsection{strace}
strace is a tool which intercepts and describes all interaction between user-side processes and the Linux kernel. You could enhance it also to understand the Binder ioctls which are used for most Android IPC. This will report on intent delivery, service binding and virtually any other Android IPC.

You will have to do quite a bit of work to make strace work in this way. There's a patch here where I started this work in 2009. I seriously doubt that this would apply to modern versions of strace, and in any case I didn't get very far, but it might be somewhere to start.
http://www.macrobug.com/opensource/strace/

\begin{lstlisting}
$strace ls /
execve("/system/bin/ls", ["ls", "/"], [/* 13 vars */]) = 0
syscall_983045(0xb0011a48, 0x2, 0xb0012570, 0, 0xb0010d8c, 0xb0009468, 0xbe81dca0, 0xf0005, 0xbe81dcb0, 0xb0007268, 0xb000726f, 0xb0007280, 0, 0xbe81dc40, 0xb0004e21, 0xb000121c, 0x80000010, 0xb0011a48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) = 0
getpid()                                = 515
sigaction(SIGILL, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0xb0009468) = 0
sigaction(SIGABRT, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0) = 0
sigaction(SIGBUS, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0) = 0
sigaction(SIGFPE, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0) = 0
sigaction(SIGSEGV, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0) = 0
sigaction(SIGSTKFLT, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0) = 0
sigaction(SIGPIPE, {0xb000586d, [], SA_RESTART}, {SIG_DFL}, 0) = 0
getuid32()                              = 0
geteuid32()                             = 0
getgid32()                              = 0
getegid32()                             = 0
stat64("/vendor/lib/liblog.so", 0xbe81d928) = -1 ENOENT (No such file or directory)
stat64("/system/lib/liblog.so", {st_mode=S_IFREG|0644, st_size=13764, ...}) = 0
open("/system/lib/liblog.so", O_RDONLY|O_LARGEFILE) = 3
lseek(3, 0, SEEK_SET)                   = 0
.. .. ..
mprotect(0x40008000, 4096, PROT_READ|PROT_WRITE) = 0
mprotect(0x40008000, 4096, PROT_READ)   = 0
mprotect(0x40008000, 4096, PROT_READ|PROT_WRITE) = 0
mprotect(0x40008000, 4096, PROT_READ)   = 0
munmap(0x40008000, 4096)                = 0
SYS_248(0, 0x1000, 0xafd46300, 0xafd46300, 0 <unfinished ... exit status 0>

\end{lstlisting}

To use strace during early initialization, you can put it in the /init.rc file. For example, to trace zygote initialization, change the following line in /init.rc.
 \begin{lstlisting}
     service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server 
    // change to :
 service zygote /system/xbin/strace -tt -o/data/boot.strace /system/bin/app_process -Xzygote /system/bin --zygote --start system-server

 \end{lstlisting}

\subsection{kdb}
kdb在Oops发生的情况下，自动起用，还是蛮不错的。编译内核时加入frame pointer等信息， 对调试Oops很有益，直接定位到函数， 再根据EIP的值，基本就能判断问题处在哪行了。
\footnote{http://forge.novell.com/modules/xfmod/project/?nlkd}
\begin{lstlisting}[basicstyle=\tiny, caption=oops log]
[    4.337934] PC: 0xc0231c1c: 
[    4.343894] 1c1c  e1a00008 e24bd028 e89daff0 c04a8660 00000ffe c04a8670 c04a86a7 c04a86ee 
[    4.350038] 1c3c  c04a8763 c0509374 c04a8780 c04a8784 c04a8791 c04a8795 c04a879b c04a879f
... ...
[    4.407300] LR: 0xc0306220: 
[    4.413584] 6220  e1a0c00d e92ddff0 e24cb004 e24dd024 e3a0a000 e1a09000 e1a0700a e2808c01 
[    4.420160] 6240  e3e02000 e50b1038 e50b8030 e50b2034 e51b3030 e5930018 e3500000 0a000023 
... ...
[    4.477627] SP: 0xcc48fe00: 
[    4.484415] fe00  c00d7d3c c00d7a54 c01475b0 00000000 00012e59 ffffffff cc48fe6c 07f28155 
[    4.491367] fe20  00000000 cc7116a0 cc48fe8c cc48fe38 c00bda2c c00bd210 00000008 00000080 
... ...
[    4.548374] IP: 0xcc48fe10: 
[    4.555111] fe10  00012e59 ffffffff cc48fe6c 07f28155 00000000 cc7116a0 cc48fe8c cc48fe38 
[    4.562002] fe30  c00bda2c c00bd210 00000008 00000080 00000007 cc7116a0 00000000 00000100 
... ...
[    4.619094] FP: 0xcc48fe0c: 
[    4.625843] fe0c  00000000 00012e59 ffffffff cc48fe6c 07f28155 00000000 cc7116a0 cc48fe8c 
[    4.632761] fe2c  cc48fe38 c00bda2c c00bd210 00000008 00000080 00000007 cc7116a0 00000000
... ...
[    4.689870] R3: 0xcc711620: 
[    4.696636] 1620  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 
[    4.703572] 1640  00000000 00000000 00000000 00000000 00000000 00000000 00000000 c0305e68
... ...
[    4.900592] Process kmmcd (pid: 193, stack limit = 0xcc48e260) 
[    4.908929] Stack: (0xcc48fe80 to 0xcc490000) 
[    4.912305] fe80: cc48fedc cc48fe90 c03062a0 c0231c9c cc48feb4 cc48fea0 c00caf08 c00cb148 
[    4.919975] fea0: cc711400 0007f281 ffffffff cc7116a0 c00c71c0 cc7115a0 cc711538 60000013 
... ...
[    5.010897] Backtrace: 
[    5.014378] [<c0231c90>] (dev_driver_string+0x0/0x44) from [<c03062a0>] (sdhci_s3c_change_clock+0x80/0x150) 
[    5.022374] [<c0306220>] (sdhci_s3c_change_clock+0x0/0x150) from [<c0303fc4>] (sdhci_set_clock+0x24/0x28) 
[    5.031619] [<c0303fa0>] (sdhci_set_clock+0x0/0x28) from [<c03044c4>] (sdhci_set_ios+0x88/0xfc) 
[    5.041435] [<c030443c>] (sdhci_set_ios+0x0/0xfc) from [<c02fb540>] (mmc_power_up+0x104/0x118) 
[    5.049976]  r6:00000000 r5:00000000 r4:00000000 
[    5.053614] [<c02fb43c>] (mmc_power_up+0x0/0x118) from [<c02fc0cc>] (mmc_rescan+0x1dc/0x2e4) 
[    5.063161] [<c02fbef0>] (mmc_rescan+0x0/0x2e4) from [<c00eedac>] (run_workqueue+0xa4/0x11c) 
[    5.071455]  r7:00000000 r6:c02fbef0 r5:cc48e000 r4:cc4813c0 
[    5.079126] [<c00eed08>] (run_workqueue+0x0/0x11c) from [<c00ef4ac>] (worker_thread+0x104/0x118) 
[    5.086800]  r7:cc48ffa4 r6:cc4813c0 r5:cc48e000 r4:cc4813c8 
[    5.094597] [<c00ef3a8>] (worker_thread+0x0/0x118) from [<c00f2ba8>] (kthread+0x5c/0x94) 
[    5.102283]  r7:00000000 r6:c00ef3a8 r5:cc4813c0 r4:cc48e000 
[    5.109452] [<c00f2b4c>] (kthread+0x0/0x94) from [<c00e1f94>] (do_exit+0x0/0x640) 
[    5.116736]  r6:00000000 r5:00000000 r4:00000000 
[    5.120379] Code: c04cba4d e1a0c00d e92dd800 e24cb004 (e5903098) 
[    5.129220] ---[ end trace 21c06b2da4da7684 ]--- 
\end{lstlisting}
Backtrace 并不是十分准确。 上面  dev_driver_string 实际 是  sdhci_s3c_change_clock 中调用的函数 sdhci_s3c_consider_clock 中调用了 宏dev_dbg 才导致的，此宏再扩展成宏    dev_printk -》dev_driver_string

”分阶段驱动(staging drivers)”

\subsection{graphviz}
为了 graphviz 能够在 Android 上不出现段错误，而修改的编译开关：
\begin{Verbatim}[fontsize=\scriptsize]
build$ git diff
diff --git a/core/combo/HOST_linux-x86.mk b/core/combo/HOST_linux-x86.mk
index 26052d6..9410f31 100644
--- a/core/combo/HOST_linux-x86.mk
+++ b/core/combo/HOST_linux-x86.mk
@@ -29,12 +29,12 @@ endef
 # requires to use the default size, as wxWidgets code otherwise
 # fails to build.
 ifneq ($(TARGET_SIMULATOR),true)
-HOST_GLOBAL_CFLAGS += -m32
-HOST_GLOBAL_LDFLAGS += -m32
+#HOST_GLOBAL_CFLAGS += -m32
+#HOST_GLOBAL_LDFLAGS += -m32
 endif
 
-HOST_GLOBAL_CFLAGS += -fPIC
+#HOST_GLOBAL_CFLAGS += -fPIC
 HOST_GLOBAL_CFLAGS += \
        -include $(call select-android-config-h,linux-x86)
 
-HOST_NO_UNDEFINED_LDFLAGS := -Wl,--no-undefined
+#HOST_NO_UNDEFINED_LDFLAGS := -Wl,--no-undefined
diff --git a/core/combo/select.mk b/core/combo/select.mk
index bd6c8c0..acb6343 100644
--- a/core/combo/select.mk
+++ b/core/combo/select.mk
@@ -46,8 +46,8 @@ $(combo_target)HAVE_STRLCPY := 0
 $(combo_target)HAVE_STRLCAT := 0
 $(combo_target)HAVE_KERNEL_MODULES := 0
 
-$(combo_target)GLOBAL_CFLAGS := -fno-exceptions -Wno-multichar
-$(combo_target)RELEASE_CFLAGS := -O2 -g -fno-strict-aliasing
+#$(combo_target)GLOBAL_CFLAGS := -fno-exceptions -Wno-multichar
+#$(combo_target)RELEASE_CFLAGS := -O2 -g -fno-strict-aliasing
 $(combo_target)GLOBAL_LDFLAGS :=
 $(combo_target)GLOBAL_ARFLAGS := crsP
 
diff --git a/core/config.mk b/core/config.mk
index 337152c..3bfb011 100644
--- a/core/config.mk
+++ b/core/config.mk
@@ -85,11 +85,11 @@ SHOW_COMMANDS:= $(filter showcommands,$(MAKECMDGOALS))
 # ###############################################################
 
 # These can be changed to modify both host and device modules.
-COMMON_GLOBAL_CFLAGS:= -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith
-COMMON_RELEASE_CFLAGS:= -DNDEBUG -UDEBUG
-
-COMMON_GLOBAL_CPPFLAGS:= $(COMMON_GLOBAL_CFLAGS) -Wsign-promo
-COMMON_RELEASE_CPPFLAGS:= $(COMMON_RELEASE_CFLAGS)
+#COMMON_GLOBAL_CFLAGS:= -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith
+#COMMON_RELEASE_CFLAGS:= -DNDEBUG -UDEBUG
+#
+#COMMON_GLOBAL_CPPFLAGS:= $(COMMON_GLOBAL_CFLAGS) -Wsign-promo
+#COMMON_RELEASE_CPPFLAGS:= $(COMMON_RELEASE_CFLAGS)
 
 # Set the extensions used for various packages
 COMMON_PACKAGE_SUFFIX := .zip
diff --git a/core/definitions.mk b/core/definitions.mk
index 7e2d1fb..85a7c45 100644
--- a/core/definitions.mk
+++ b/core/definitions.mk
@@ -1172,17 +1172,13 @@ endef
 ifneq ($(HOST_CUSTOM_LD_COMMAND),true)
 define transform-host-o-to-executable-inner
 $(HOST_CXX) \
-       -Wl,-rpath-link=$(TARGET_OUT_INTERMEDIATE_LIBRARIES) \
-       -Wl,-rpath,\$$ORIGIN/../lib \
        $(HOST_GLOBAL_LD_DIRS) \
        $(PRIVATE_LDFLAGS) \
        $(if $(PRIVATE_NO_DEFAULT_COMPILER_FLAGS),, \
                $(HOST_GLOBAL_LDFLAGS) \
        ) \
        $(PRIVATE_ALL_OBJECTS) \
-       -Wl,--whole-archive \
        $(call normalize-host-libraries,$(PRIVATE_ALL_WHOLE_STATIC_LIBRARIES)) \
-       -Wl,--no-whole-archive \
        $(call normalize-host-libraries,$(PRIVATE_ALL_STATIC_LIBRARIES)) \
        $(call normalize-host-libraries,$(PRIVATE_ALL_SHARED_LIBRARIES)) \
        -o $@ \
==============================graphviz build flag work end===================
\end{Verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{优化工具}
\subsection{MethodTracing}
用于热点分析和性能优化，分析每个函数占用的CPU时间，调用次数，函数调用关系等

\begin{enumerate}
    \item 在程序代码中加入追踪开关
        \begin{lstlisting}[language=java]
            import android.os.Debug;
            .. .. ..;
             // 先建 /data/tmp 目录
            android.os.Debug.startMethodTracing(“/data/tmp/test”);
            .. .. ..; // 被追踪的程序段
            android.os.Debug.stopMethodTracing();
        \end{lstlisting}

    \item 编译，运行后，设备端生成/data/tmp/test.trace文件

    \item 把trace文件复制到PC端

        \lstinline{$ adb pull /data/tmp/test.trace ./}

    \item 使用android自带工具分析trace文件

        \lstinline{$ traceview test.trace}
        此时可看到各个函数被调用的次数CPU占用率等信息

    \item 使用android自带工具分析生成调用关系类图（安装graphviz）

        \lstinline{$dmtracedump -g test.png test.trace}
        此时目录下生成类图test.png。
\end{enumerate}

trace文件生成与libdvm模块DEBUG版本相冲突，所以此方法只适用于对非DEBUG版本模拟器的调试，否则在分析trace文件时会报错

\subsection{android.os.Debug的其他工具}
\begin{enumerate}
    \item 取毫微秒级的时间，用于计算时间

        threadCpuTimeNanos();

    \item 统计两点间的内存分配情况

        startAllocCounting();\\
        stopAllocCounting();\\
        getGlobalAllocCount();

    \item 打印当前已load的class

        getLoadedClassCount();\\
         //  需要打开NDEBUG功能才能打开system/core/中Log功能\\
        printLoadedClasses(); 
\end{enumerate}

\subsection{SamplingProfile}
每隔Ｎ毫秒对当前正在运行的函数取样，并输出到log中。

\begin{lstlisting}[language=java]
    import dalvik.system.SamplingProfiler
    ……
    SamplingProfile sp = SamplingProfiler.getInstance();
    sp.start(n); // n 为设定每秒采样次数
    sp.logSnapshot(sp.snapshot());
    ……
    sp.shutDown();
\end{lstlisting}
    它会启一个线程监测，在logcat中打印信息


\subsection{HProf}
用于java层面的内存分析，显示详细的内存占用信息，指出可疑的内存泄漏对象
\begin{enumerate}
    \item  在代码中加入dump动作

        \begin{lstlisting}[language=java]
            import android.os.Debug;
            import java.io.IOException;
            ……
            try {
                // /data/tmp  目录要已建立，否则建立这个目录
                android.os.Debug.dumpHprofData(“/data/tmp/input.hprof”); 
            } catch (IOException ioe) {
            }
        \end{lstlisting}

    \item  把hprof文件复制到PC端

        \lstinline{$ adb pull /data/tmp/input.hprof ./}

    \item 使用命令hprof-conv把hprof转成MAT识别的标准的hprof

        \lstinline{$ hprof-conv input.hprof output.hprof}

    \item  使用ＭＡＴ工具看hprof信息\marginal{Mat 已有 Eclipse 插件}

        下载MAT工具：http://www.eclipse.org/mat/downloads.php ，用工具打开output.hprof
\end{enumerate}

\section{烧写系统fastboot}
fastboot 是用来更新Android系统，即把镜像文件烧入目标机上、查出目标机的数据。
Android 还有个 Recovery 模式也可以更新系统，但是两者是不一样的：
\footnote{recovery分区是其根文件系统，是简化版的ramdisk. SD卡的分区不在系统分区讨论之列。}
    \tabcaption{Recovery 升级与 fastboot 升级比较} \label{ex:tableupdate} 
%\begin{table}[!th]
    %\caption{Recovery 升级与 fastboot 升级比较} \label{ex:tableupdate} 
    \begin{tabular}{|p{0.5\linewidth} |p{0.5\linewidth}|}%{|l|c|r|}
        \hline
             fastboot           &      recovery \\\hline
          bootloader(如uboot) 里提供的功能   
                     &  用户空间的程序，需要启动内核，并带起recovery，升级程序updater在升级包里。  \\\hline
           需要主机与目标机连接，从主机控制台的命令行向目标发生命令，升级文件也是从主机传送过去的。 
                     &  Recovery 直接在目标机上操作，提供了简单的人机交互界面
                     。升级文件需要预先拷贝或下载到目标机上。 \\\hline
         能擦除、烧入目标系统的各个分区 ，包括 bootloader 等，可以单独，也可以一起
                        烧入镜像，可烧入比现系统旧的系统。
                     & 不能升级bootloader，只能擦除 cache 、userdata，一次性升
                     级系统、内核、根文件系统，而且升级的系统必须比现系统新。\\\hline
          \begin{list}{$\bullet$}{\listparam} 
          \item adb shell reboot bootloader
          \item bootloader 启动后在串口输入fastboot
          \item 特定按键组合启动 
          \end{list}
              &  \begin{list}{$\bullet$}{\listparam}
              \item adb shell reboot recovery 
              \item 更改bootloader 的引导内核参数 
              \item 特定按键组合启动 \end{list}\\
        \hline
    \end{tabular}
%\end{table}

\subsubsection{fastboot 命令}
以下列出一些常用命令， 更多的使用命令， fastboot - -help

\begin{enumerate}
    \item [察看连接] 
        fastboot devices 

    \item [清除分区] 
        \begin{itemize}
            \item fastboot erase bootloader（清除u-boot） 
            \item fastboot erase kernel （清除kernel） 
            \item fastboot erase userdata（清除用户数据） 
            \item fastboot erase recovery（清除recovery） 
            \item fastboot erase system（清除系统） 
        \end{itemize} 

    \item [镜像烧入分区] 
        \begin{itemize}
            \item fastboot flashall
            \item fastboot flash bootloader uboot.bin         (刷bootloader) 
            \item fastboot flash userdata userdata.img        (刷用户数据) 
            \item fastboot flash recovery recovery-uboot.img  (刷recovery)
            \item fastboot flash system system.img            (刷Android系统)
            \item fastboot flash boot boot.img                (刷内核和根文件系统)
            \item fastboot flash radio radio.img              (刷无线系统分区)
            \item fastboot flash kernel zImage                (刷内核)
            \item fastboot flash ramdisk ramdisk-uboot.img    (刷根文件系统)
        \end{itemize}

    \item [重启系统] 
        fastboot reboot 
\end{enumerate}

\begin{verbatim}
boot其实包含了kernel和ramdisk, Android原始的是把两者放在一个分区，而三星把两个分开的。分开的好处是，recovery.img 里不包含内核，其正常启动(加载ramdisk)和Recovery模式使用了相同的内核。加uboot的头部信息：
    mkimage -A arm -O linux -T ramdisk -C none -a 0x30800000 \
            -n "ramdisk" -d recovery.img recovery-uboot.img
boot.img 的制作
    mkbootimg --kernel zImage --ramdisk ramdisk-uboot.img -o boot.img
\end{verbatim}

*****************************烧写步骤************************************
\begin{verbatim} 

准备工作:
连接miniUSB到PC;
连接UART2到电脑串口。
fastboot 在 Android SDK 或编译好的Android系统都有， 
把它加入环境变量：
    $vi ~/.bashrc 
    加入 export PATH="$PATH:~/android/sdk/platform-tools/"
    $source ~/.bashrc

1.机器进入fastboot状态: 
(1)打开minicom 
$ minicom 
(2)开机后，在串口终端显示:
In:      serial
Out:     serial
Err:     serial
checking mode for fastboot ...
Hit any key to stop autoboot: 5
按任意键后：
SMDKC110 #

(2)进入fastboot状态： 
SMDKC110 # fastboot
Fastboot: employ default partition information
[Partition table on OneNAND]
ptn 0 name='bootloader' start=0x0 len=0x100000(~1024KB) 
ptn 1 name='recovery' start=0x100000 len=0x500000(~5120KB) 
ptn 2 name='kernel' start=0x600000 len=0x500000(~5120KB) 
ptn 3 name='ramdisk' start=0xB00000 len=0x300000(~3072KB) 
ptn 4 name='system' start=0xE00000 len=0x5A00000(~92160KB) (Yaffs)
ptn 5 name='cache' start=0x6800000 len=0x5000000(~81920KB) (Yaffs)
ptn 6 name='userdata' start=0xB800000 len=N/A (Yaffs)

2. 烧写代码到OneNand里:
再开一个终端
(1) 所有文件在out/target/product/t12c110这里
$ cd $FROYO_DIR/out/target/product/t12c110
(2)列出你的手机设备 ：
$ fastboot devices
SMDKC110-01 fastboot
(3)烧u-boot
$ fastboot flash bootloader u-boot-config_fused.bin 一般不用，如果是空片，用SD卡等方式启动时才需要
(4)烧zImage和ramdisk-uboot.img(boot.img=zImage+ramdisk-uboot.img)。
$ fastboot flash kernel zImage
$ fastboot flash ramdisk ramdisk-uboot.img
(5) 烧写system.img
$ fastboot flash system system.img
(6) 清除用户数据和cache
$ fastboot erase userdata
$ fastboot erase cache
\end{verbatim}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{测试}
\subsection{monkey}\label{monkey}
monkey -v -p com.android.launcher 500
表示对com.android.launcher 进行500次测试。

代码在development/cmds/monkey/

\subsection{cts}
 ./startcts
   start --plan Android -t



\section{模拟器}
\begin{verbatim}
$android                      #android SDK 下载管理工具
$android list                #列出Android SDK 安装的组件 

Android 模拟器启动 
$emulator @sd -shell-serial 
如果不使用 AVD 设备里指定的镜像文件，可以使用如下命令： 
$emulator -system system.img   -data userdata.img  -ramdisk ramdisk.img \
-kernel kernel/arch/arm/boot/zImage @sd 

其他选项 
-help                      帮助信息
-verbose                显示emulator调用log， 等价于  -debug-init 
-debug   <tags>     tags 是all，或者是init、console、modem、radio、keys的任意组合(以”,”分割)
-logcat v                 启动logcat，跟 adb logcat 相当。
-show-kernel          打印内核的启动信息 
-avd <name>         相当于 @ <name> 指定 虚拟设备（Android Virtual Device） 
-trace <filename>  文件保存在~/.android/avd/<avdname>.avd/traces/<filename>，记录trace消息， 
                                  按9开始、停止记录。
-tcpdump <file>       把抓到的网络包保存到本地文件

-partition-size   指定/system、/data两个分区的大小 
-sdcard 
-memory 
-cpu-delay 0 
-prop dalvik.vm.heapsize = 32m    Dalvik 虚拟机的堆设置 32M Byte。 


# df       
/dev: 47048K total, 0K used, 47048K available (block size 4096) 
/mnt/asec: 47048K total, 0K used, 47048K available (block size 4096) 
/system: 76544K total, 76544K used, 0K available (block size 4096) 
/data: 65536K total, 31784K used, 33752K available (block size 4096) 
/cache: 65536K total, 1156K used, 64380K available (block size 4096) 
/mnt/sdcard: 258064K total, 170870K used, 87193K available (block size 512) 
/mnt/secure/asec: 258064K total, 170870K used, 87193K available (block size 512)

/system 分区已没有空间，可以使用-partition-size 选项。
$ emulator @hasd -logcat v -shell -partition-size 128
\end{verbatim}

\subsubsection{控制台}
\begin{verbatim}
在模拟器远行后，查询模拟器使用的端口：
$ adb devices 
List of devices attached 
emulator-5554	device

$telnet localhost   5554
登入Android Console。开发板需要连上网线。而adb走的是串口。

一些命令：
window scale 0.8                             # 模拟器窗口缩为0.8
sms send 13451851888  “Hello”    #向号码13451851888 发送短信，内容是“Hello ”
power status full                             #电池状态
power ac off                                    #关闭 AC充电

Android Console 的代码及相关指令可以参考代码，external/qemu/android/console.c
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ADT 的调试工具}
\subsection{tarceview}

\begin{lstlisting}
onCreate

  android.os.Debug.startMethodTracing(
                    android.os.Environment.getExternalStorageDirectory() + "/launcher");

onDestroy

android.os.Debug.stopMethodTracing();
\end{lstlisting}

adb pull /sdcard/launcher.trace /tmp


traceview /tmp/launcher.trace

\subsection{hierarchyviewer}

\subsection{DDMS}
当调试内存泄漏等问题时，我们要看到进程的情况。但往往 DDMS 的 Devices 里没有进
程显示出来。 
网上这方面的问题，都说 adb root 或机器root的问题，而我这里都root还不行。

后来发现， Eclipse 控制台日志显示 ddms 启动时的信息，再到网上查询，原来的原因
是要在AndroidManifest.xml 里加入 android:debuggable="true" （application 的属
性里）才能在ddms显示这个进程的。
\subsection{eclipse}
\subsubsection{android.jar 的源码链接}
传建 Android 中，会包含 Android包 android.jar，但是这个包里只是编译过的字节码和资源，没有源码。在ddms调试代码时，打开相应的 Android Framework 的类时，在类名、常变量名按F3查看实现时，呈现给你的是毫无意义的.class文件。

有一个解决方法：
如果Android包 是~/android/sdk/platforms/android-8/android.jar，那么在 android.jar所在的目录下建一个目录sources。把Android 工程中frameworks/base/core/java目录下的文件全都拷贝到这个目录中，这是framework 的源码; 再把libcore/luni/src/main/java、libcore/luni-kernel/src/main/java目录中的文件也拷贝进来，这些是Java 的基本类的实现代码。android.jar 其余类的源码基本都在frameworks及libcore两个目录中，按需要添加吧。


\begin{lstlisting}
leo@leo-desktop:~/android/platforms/android-7/sources$ ln -s /home/leo/android_2.1_20100506/android/libcore/luni/src/main/java java
leo@leo-desktop:~/android/platforms/android-7/sources$ ln -s /home/leo/android_2.1_20100506/android/frameworks/base/core/java/android ./android
\end{lstlisting}
\footnote{Oh, Eclipse 3.5 have a bug, if the source path include more than one
soft link, it will omit the first soft link.}

源码可以使用下面的脚本\ref{copyandroid}.
原理是：
\begin{lstlisting}
sdk/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/project/AndroidClasspathContainerInitializer.java:636:        paths.add(target.getPath(IAndroidTarget.SOURCES)); 

sdk/sdkmanager/libs/sdklib/src/com/android/sdklib/SdkConstants.java:212:    public static final String FD_ANDROID_SOURCES = "sources"; 
\end{lstlisting}

\begin{verbatim}
sdk/sdkmanager/libs/sdklib/src/com/android/sdklib/PlatformTarget.java
方法PlatformTarget
        mPaths.put(SOURCES, mRootFolderOsPath + SdkConstants.FD_ANDROID_SOURCES);

据网上资料，以前(2.2)是放在com.android.ide.eclipse.adt.project.internal包中的，
plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/AndroidConstants.java:
public static final String FD_ANDROID_SOURCES = "sources";
\end{verbatim}


\subsubsection{如何在eclipse调用 sdk 中隐藏的API}
@hide 标记的类或方法，sdk 都没有导出其存根的，即使这些类是public的。
首先，下载Android源码进行编译。然后在编译后的out目录下寻找包含你所用隐藏类的模
块的jar文件，通常文件名为classes.jar。比如framework的jar文件为
out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar。


最后在eclipse的Android项目中，选择项目属性->Java Build Path->Libraries->Add
Library->User Library->Next-> User Libraries进入到User Libraries管理界面，点击
New新建一个User Library，比如android_framework，点击Add Jars把Jar包加入到建立
的User Library中，最后点击OK就可以了。

为了访问因此成员，需要改变类搜索顺序，选择项目属性->Java Build Path->Order
and Export，把所建立的User Libraries移到Android SDK的上面。

但是，貌似，不能编译通过。只能是eclipse 语法检查没报错。

\subsubsection{android.jar的属性}

android.jar 的属性中不允许修改源码链接。Google这么做是考虑到程序安全问题吧！我们开发中这个累赘，或许我们修改一下 android.jar的编译选项可以去掉这个限制。

哈哈，后来发现修改 sources.properties 可以去掉这个限制。

修改~/android/sdk/platforms/android-9/sources.properties
加入一行 : 
 Pkg.UserSrc=true
在工程里就可以设置 android.jar 的源代码的路径,

这个没有去查看代码， 但可以肯定的是，这是 adt 做的手脚。

\subsubsection{拷贝 Android SDK 的代码}
\label{copyandroid}
下面是一段 Python 代码，把这段代码放在一个脚本里，把脚本放在 Android 的根目录
，编译 Android 工程后，运行一下即可。
\begin{lstlisting}[language=python]
#!/usr/bin/python
from __future__ import with_statement  # for Python < 2.6
__author__ = 'Damon Kohler <damonkohler@gmail.com>\n'
'Xu shenlong <shecenong@gmail.com>'

import os
import re
import shutil
import subprocess
import sys
import zipfile
from optparse import OptionParser

destdir = "sources"
packages = {}
def do_source(src_list):
    with open(src_list) as f:
        for line in f:
            javas=line.strip(" ").split(" ")
            for java in javas:
                copy_java_file(os.path.join(workdir, java))
######
def copy_java_file(path):
    if not os.path.isfile(path):
        print path , "is not a file"
        return

    with open(path) as f:
        for line in f:
            match = re.match(r'\s*package\s+([A-Za-z0-9\._]+);', line)
            if match:
                package = match.group(1).replace('.', os.sep)
                if package not in packages:
                    try:
                        os.makedirs(os.path.join(destdir, package))
                        packages[package] = True
                    except os.error:
                        pass
                destination = os.path.join(destdir, package, os.path.basename(path))
                shutil.copy(path, destination)
                break

if __name__ == '__main__':
    opt = OptionParser()
    opt.add_option("-w", "--workdir",  action="store", type="string", dest="workdir",
            help="android source top dir", metavar="~/android")
    opt.add_option("-d", "--destination", action="store", type="string", dest="dest",
            help="the path where put sources",
            metavar="~/android/sdk/platform/android-9/sources")
    opt.add_option("-l", "--sourcelist", action="store", type="string", dest="src_list",
            help="java source code files list",
            metavar="droiddoc-src-list")
           # metavar="~/android/out/target/product/e9/obj/JAVA_LIBRARIES/apt-stub_intermediates/droiddoc-src-list")

    (options, sys.args) = opt.parse_args()

    if options.workdir:
        workdir=options.workdir
    else:
        workdir=os.getcwd()
        print "specified android source tree path to " + workdir
        #sys.exit(1)

    if options.dest:
        destdir=options.dest
    else:
        destdir=os.path.join(workdir, "out/host/sdk-sources")
        #destdir=workdir + "out/host/sdk-sources"
        print "specified destination path to " + destdir
        #sys.exit(1)

    try:
        if options.src_list:
            do_source(options.src_list)
        else:
            products = os.listdir(os.path.join(workdir, "out/target/product"))
            #products = os.listdir(workdir + "out/target/product")
            print "products is " + str(products)
            for product in products:
                src_list= os.path.join(workdir, "out/target/product", product,
                        "obj/JAVA_LIBRARIES/api-stubs_intermediates/droiddoc-src-list")
                print src_list
                if os.path.exists(src_list):
                    #print "do copying according to " + src_list
                    do_source(src_list)
                    break
                else:
                    print "do not exitts " + src_list
    except KeyboardInterrupt:
        print '\n Interrupt by keyboard'
    else:
        print 'Android SDK source copy done!'

    sys.exit(0)
\end{lstlisting}

\subsubsection{Eclipse configuration}
\begin{verbatim}
安装路径 /usr/lib/eclipse

1）、修改eclipse缓存设置
　　把eclipse.ini（在eclipse软件的安装目录下）的3个值改为下面的值：
　　-Xms128m
　　-Xmx512m
　　-XX:MaxPermSize=256m

　　2）、把android-formatting.xml和 android.importorder导入eclipse
　　android-formatting.xml、.classpath和 android.importorder都放在development/ide/eclipse/下
　　android- formatting.xml用来配置eclipse编辑器的代码风格；android.importorder用来配置eclipse的import的顺序和结构。
　　在 window->preferences->java->Codestyle->Formatter中导入android- formatting.xml
　　在 window->preferences->java->Codestyle->OrganizeImports中导入 android.importorder 
\end{verbatim}


\section{编译}
\subsection{搭建编译环境}
编译Android前需要安装的软件包

以下内容摘自：http://source.android.com/source/download.html
\begin{quotation}
Ubuntu Linux (64-bit x86)
This has not been as well tested. Please send success or failure reports to
android-porting@googlegroups.com .  The Android build requires a 32-bit build
environment as well as some other tools: Required Packages: Git, JDK, flex,
and the other packages as listed above in the i386 instructions: JDK 5.0,
update 12 or higher.Java 6 is not supported, because of incompatibilities with
@Override.  Pieces from the 32-bit cross-building environment X11 development 

{\color{red} \$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl sun-java5-jdk zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev ia32-libs x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev
}

Set the system to use the right version of java by default: 
{\color{red} \$ sudo update-java-alternatives -s java-1.5.0-sun}

X11: Ubuntu doesn't have packages for the X11 libraries, but that can be
worked around with the following command: 
{\color{red} \$ sudo ln -s /usr/lib32/libX11.so.6 /usr/lib32/libX11.so }
\end{quotation}

X11的问题没有碰到。至于JDK，从 Android 的编译脚本来看，Android 2.1 以前（包括
2.1）使用 1.5，2.2使用的 1.6。问题是 JDK 1.5现在不维护了，而且在Ubuntu 10.04里
的源里只有JDK 1.6的包。

至于，Android交叉编译时所用的工具链是Android工程自带的，一般放在目录
prebuilt/linux-x86/toolchain下，包括X86，ARM，以及SH （SuperH）等架构，具体以
build/core/combo/目录下以”TARGET_linux”开头的mk文件中指定的变量“
TARGET_TOOLS_PREFIX”为准。

\subsubsection{可能出现的问题}
1.libstdc++.so 链接问题
现象：
%\begin{Verbatim}[fontsize=\small] 
\begin{lstlisting}[language=]
host SharedLib: libneo_util (out/host/linux-x86/obj/lib/libneo_util.so)
/usr/bin/ld: skipping incompatible /usr/lib/gcc/i486-linux-gnu/4.3.4/libstdc++.so when searching for -lstdc++
/usr/bin/ld: skipping incompatible /usr/lib/gcc/i486-linux-gnu/4.3.4/libstdc++.a when searching for -lstdc++
/usr/bin/ld: cannot find -lstdc++
collect2: ld returned 1 exit status
make: *** [out/host/linux-x86/obj/lib/libneo_util.so] 错误 1
\end{lstlisting}
%\end{Verbatim}
解决方法： 缺少g++-multilib库，安装即可： sudo apt-get install g++-multilib   
把 /usr/lib/gcc/x86_64-linux-gnu/4.4.3/libstdc++.so 链接到
/usr/lib32/libstdc++.so.6，也可以解决问题，不推荐。

2.libz.so链接问题
\begin{lstlisting}[language=]
host Executable: aapt (out/host/linux-x86/obj/EXECUTABLES/aapt_intermediates/aapt) 
/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../libz.so when searching for -lz 
/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../libz.a when searching for -lz 
/usr/bin/ld: skipping incompatible /usr/lib/libz.so when searching for -lz 
/usr/bin/ld: skipping incompatible /usr/lib/libz.a when searching for -lz 
/usr/bin/ld: cannot find -lz 
collect2: ld returned 1 exit status 
\end{lstlisting}
解决方法：
  缺少lib32z1-dev库，安装： sudo apt-get install lib32z1-dev
以上问题比较常见。只要按照官方的指导进行编译，就不会出现这些问题了。
\subsection{基本编译}

\tabcaption{Android 编译的目标和参数}
\begin{tabular}{|p{0.36\textwidth}|p{0.64\textwidth}|}\hline
make eng & 也可以 user，userdebug。发布版本编译的一些变体，区别在安装模块、软
件包和是否可以调试。在不同变体间切换前，请用 make installclean 清理安装
。\\\hline
make droid & 编译 Android 系统，droid是默认的目标 \\\hline
make bootimage & 制作boot.img\\\hline
make snod & 重新生成system.img\\\hline
make dist &\\\hline
make otapackage &  制作 Recovery的升级包\\\hline
make ramdisk & 制作根文件系统 \\\hline
make sdk & 编译 Android sdk  \\\hline
make modules & 打印工程的所有模块。\\\hline
make <MODULE> & 编译模块 <MODULE> ，如 make libc 编译libc（bionic/libc模）\\\hline
make clean-<MODULE> & 清理模块 <MODULE> 编译的目标文件和中间文件。\\\hline
make clean &清除当前编译配置生成输出和中间文件。相当rm -f out/<configuration>。\\\hline
make clobber &清除所有配置的输出和中间文件。 相当于 rm -f out\\\hline
make dataclean &\\\hline
make installclean & 清理安装的文件\\\hline

\end{tabular}
在build/core/main.mk 及build/core/Makefile两个文件中有许多伪目标, 比如otapackage, recoveryimage。
在以上的命令中，加上 “showcommands”，会打印编译时使用的命令， -j 指定多核同步
编译。如：\\*
\mbox{\$make sdk showcommands -j 4}

多核编译，有时以为同步会出现依赖问题，这时去掉 -j 或直接重新编译即可解决。更多详细内容，请参考：
build-system.html \footnote{build/core/build-system.html, http://source.android.com/porting/build_system.html}
\\*
\$make -j8 PRODUCT-sdk-sdk showcommands dist

\$ vi buildspec.mk         ＃　新建配置文件
加入如下内容
\begin{lstlisting}
CUSTOM_LOCALES:=zh_CN     # 设置编译为中文系统
WITH_JIT:=true            # 加入JIT支持，使得运算速度加快1-2倍
\end{lstlisting}

以下如果没有特别说明，默认的当前工作目录是工程的顶级目录。只需输入：
\vbox{\$make } 就会编译整个Android工程的代码。这相当于:
\vbox{\$make PRODUCT-generic-eng}

\begin{verbatim}
distcc   分布式编译工具

C 代码的编译命令序列，在文件definition.mk中定义：
transform-host-c-to-o-no-deps   （host，aapt）

transform-c-to-o-no-deps （target， 什么时候使用？）


C++ 代码的编译命令序列，在文件definition.mk中定义：
transform-host-cpp-to-o   （host，aapt）

transform-cpp-to-o        （target， 什么时候使用？）


aapt 的链接命令：
transform-host-o-to-executable  definition.mk

LOCAL_CFLAGS is  -Wno-format-y2k
LOCAL_CPPFLAGS is 
HOST_GLOBAL_CFLAGS is -fno-exceptions -Wno-multichar -m32 -fPIC
                    -include system/core/include/arch/linux-x86/AndroidConfig.h
                    -DANDROID -fmessage-length=0 -W -Wall -Wno-unused 
                    -Winit-self -Wpointer-arith -O2 -g -fno-strict-aliasing 
                    -DNDEBUG -UDEBUG

HOST_GLOBAL_CPPFLAGS is -DANDROID -fmessage-length=0 -W -Wall -Wno-unused
                    -Winit-self -Wpointer-arith -Wsign-promo -DNDEBUG -UDEBUG

build/core/combo/HOST_linux-x86.mk:36:
    HOST_GLOBAL_CFLAGS += -fPIC
build/core/combo/select.mk:50:
    $(combo_target)RELEASE_CFLAGS := -O2 -g -fno-strict-aliasing

build/core/config.mk:277:HOST_GLOBAL_CFLAGS += $(COMMON_GLOBAL_CFLAGS)
build/core/config.mk:305:HOST_GLOBAL_CFLAGS += $(HOST_RELEASE_CFLAGS)
# These can be changed to modify both host and device modules.
COMMON_GLOBAL_CFLAGS:= -DANDROID -fmessage-length=0 -W -Wall -Wno-unused \
                       -Winit-self -Wpointer-arith
COMMON_RELEASE_CFLAGS:= -DNDEBUG -UDEBUG

COMMON_GLOBAL_CPPFLAGS:= $(COMMON_GLOBAL_CFLAGS) -Wsign-promo
COMMON_RELEASE_CPPFLAGS:= $(COMMON_RELEASE_CFLAGS)

LOCAL_MODULE_TAGS 取值可以是   user  optional  gnu tests debug eng 其中之一。
ALL_MODULE_TAGS 的值就是 LOCAL_MODULE_TAGS 取值的集合， 即:
    "user  optional  gnu tests debug eng"

ALL_MODULE_TAGS.user := out/target/product/generic/system/lib/libc.so
                        out/target/product/generic/system/lib/libdl.so
                        out/target/product/generic/system/lib/libm.so
                        ....
ALL_MODULE_NAME_TAGS.user := libc libdl libm libstdc++ libthread_db
                             libjavacore linker core
                             ...
ALL_MODULE_NAME_TAGS.optional := Camera Fallback Gallery 
                            ...
ALL_MODULE_NAME_TAGS.tests := core-Tests
                              CameraTests
                              SnakeTests
                              run-core-tests
                              ...
\end{verbatim}

\subsection{编译后的目录结构}
编译生成的中间文件和目标文件存放在目录
out/host/linux-x86/obj/EXECUTABLES/aapt_intermediates/
安装到目录 out/host/linux-x86/bin

编译后，会在工程的最上级目录下建立一个out的目录，所以与编译中产生的中间文件、目标文件、库文件、可执行文件、Apk包、以及最终的镜像文件等，都放在这里。目录组织的结构：
	先分debug和release，默认是release，直接放在out目录下，debug的文件放在out/debug目录下; 	再分host和target，host放的是Android的开发工具，如aapt、adb、ddms等就放在out/host/linux-x86/bin下，以及Android SDK
//TODO



\subsection{编译优化}
\subsubsection{模块编译}
\begin{verbatim}
$cd ~/android/platform
$source build/envsetup.sh
$mmm packages/apps/Launcher2 
$adb remount
$adb push out/target/product/generic/system/app/Launcher2.apk /system/app

OK了，等着新的版本自动启动。 
app$ adb shell stop zygote
app$ adb shell start zygote
之后，系统重启
后面的两步不要，Launcher2也会启动为新版本的。


adb install -r xxx.apk
-r参数会强制卸载老版本，安装新版本。
\end{verbatim}
开发 Android应用时，借助 Eclipse ，编码、编译、运行、调试，一气呵成。但是如果
修改Android 自带的程序，或者如 Frameworks 等代码的，就难以使用 Eclipse
开发，现在一般是在命令行操作。这时有什么方法可以减少编译、启动的时间呢？可以按
下面步骤实施：

\begin{enumerate}
    \item 加载脚本, 下面两个是等效的
        \begin{lstlisting}[numbers=none]
            $source build/envsetup.sh     
            $ .  build/envsetup.sh     
        \end{lstlisting}
        这样mmm等命令就可以使用了。由于mmm是函数，只在当前的shell中有效，这也
        是用source加载脚本的原因。其他的命令见\ref{compilecommand}.
    \item 编译模块
        \\*\$mmm packages/app/Launcher2
        mmm只需要指定目录即可，当然这个目录下必须有Android.mk的Makefile。编译，目标文件放在
        /out/target/product/generic/system/app。
    \item 重新挂载 /system
        \\*\$adb remount

        注意：把adb所在的目录放在环境变量PATH，或者指定路径，如out/host/linux-x86/bin/adb，并具有指向权限。如果是USB连接到开发板，请以超级用户的权限运行 adb server，再remount。
        \begin{lstlisting}[numbers=none]
  $adb kill-server        #如果server没运行可以略过
  $sudo adb start-server
        \end{lstlisting}
        默认情况，/system挂载的文件系统只读，需要重新挂载为可读写。
    \item 安装, 两种选择
      \begin{lstlisting}[numbers=none]
  $adb push out/target/product/generic/system/app/Launcher2.apk /system/app
  $adb install -r out/target/product/generic/system/app/Launcher2.apk
        \end{lstlisting}
\end{enumerate}

Android在发现程序文件被更新后，会重新启动应用程序，我们就可以调试了。以后，我
们只需重复步骤2和4，快速编译，热更新模块，开发效率也很高，而不需要重新编译这个
工程、重新烧录镜像文件、重启系统等费时的工作。 

\tabcaption{envsetup提供的编译工具 }\label{compilecommand}
\begin{tabular}{|l|l|}\hline
    printconfig & 打印工程当前编译配置\\\hline
    lunch       & 选择编译配置\\\hline
    choosecombo & 逐项选择编译配置\\\hline
    mm & 编译指定目录及其所有子目录里的工程\\\hline
    mmmm & 编译指定目录的工程\\\hline
\end{tabular}

如果更新了framewok.apk 或者 共享库时，需要同步一下。
\\* \$adb shell sync

\mbox{mmm frameworks/policies/base/phone/ showcommands}

不能编译出 out/target/product/generic/system/framework/android.policy.jar
make android.policy -j 4
才可以。原因是， frameworks/policies/base/PolicyConfig.mk 配合  frameworks/policies/base/phone/Android.mk

共享库也可以热更新
\begin{lstlisting}
    $mmm frameworks/base/libs/binder
    $adb push out/target/product/generic/system/lib/libbinder.so  /system/lib
\end{lstlisting}

\subsubsection{加快Android单模块编译}
习惯了automake之后，再用Android的编译系统，就是感觉不爽。编译一个小模块也等上
几分钟，有次实在受不了，看了一下它的实现，发现它对任何一次编译都要查找所有的
Android.mk：

subdir_makefiles=\$(shell cat build/tools/Android.mk.cache)

我把build/core/main.mk修改了一下，增加了一个cache：
\begin{lstlisting}
subdir_makefiles=$(shell cat build/tools/Android.mk.cache)
ifeq ($(subdir_makefiles),)
$(info "no cache. create build/tools/Android.mk.cache")
$(shell build/tools/findleaves.sh --prune="./out" . Android.mk > build/tools/Android.mk.cache)
subdir_makefiles=$(shell cat build/tools/Android.mk.cache)
else
$(info "use cache: build/tools/Android.mk.cache")
endif
\end{lstlisting}

速度终于可以接受了。

\subsubsection{不自动清理}
\begin{Verbatim}
如果 make 和 make sdk ，那 Android 默认的编译系统会清理安装的文件，可以按以下
的方式避免：
core/cleanbuild.mk   
DISBALE_AUTO_INSTALLCLEAN := true
DISBALE_AUTO_INSTALLCLEAN := false
make clean
make

命令行定义变量：
$ DISABLE_AUTO_INSTALLCLEAN=true mmm \
>frameworks/base/camera/tests/CameraServiceTest/
这个在编译SDK 和 eng之间切换时不会清理。
\end{Verbatim}

\subsubsection{避免编译文档}
\begin{verbatim}
如何避免编译 SDK 文档， 编译 Android SDK docs 很费内存资源，而且在一般的开发也没必要
platform$ find ./  -name "*.mk" | xargs grep -n --color 'BUILD_DROIDDOC'
./dalvik/dx/src/Android.mk:34:include $(BUILD_DROIDDOC)
./dalvik/tools/dexdeps/src/Android.mk:31:include $(BUILD_DROIDDOC)
./frameworks/base/Android.mk:477:include $(BUILD_DROIDDOC)
./frameworks/base/Android.mk:513:include $(BUILD_DROIDDOC)
./frameworks/base/Android.mk:549:include $(BUILD_DROIDDOC)
./frameworks/base/Android.mk:574:include $(BUILD_DROIDDOC)
./frameworks/base/services/java/Android.mk:18:include $(BUILD_DROIDDOC)
./build/core/config.mk:69:BUILD_DROIDDOC:= $(BUILD_SYSTEM)/droiddoc.mk
./build/tools/droiddoc/test/generics/Android.mk:28:include $(BUILD_DROIDDOC)
./build/tools/droiddoc/test/stubs/Android.mk:28:include $(BUILD_DROIDDOC)
./device/sample/frameworks/PlatformLibrary/Android.mk:48:include $(BUILD_DROIDDOC)
./development/pdk/Pdk.mk:198:include $(BUILD_DROIDDOC)
\end{verbatim}


挂载 SD 文件镜像\\
sudo mount -o loop ~/.android/avd/sd.avd/sdcard.img /mnt

\begin{verbatim}
Install: out/host/linux-x86/bin/acp 
Install: out/host/linux-x86/framework/apicheck.jar acp 
/bin/bash: out/host/linux-x86/bin/acp: 没有那个文件或目录 
make: *** [out/host/linux-x86/framework/apicheck.jar] 错误 127 
base_rules.mk  
$(LOCAL_INSTALLED_MODULE)  
$(LOCAL_ACP_UNAVAILABLE)为true，即out/host/linux-x86/bin/下acp不存在时要调用cp, 如果把$ (copy-file-to-target-with-cp)注释调了, acp无法拷贝到out/host/linux-x86/bin/下.


Checking API: checkapi-last 
java.io.FileNotFoundException: out/target/common/obj/PACKAGING/public_api.xml (No such file or directory) 
	at java.io.FileInputStream.open(Native Method) 
	at java.io.FileInputStream.<init>(FileInputStream.java:106) 
	at java.io.FileInputStream.<init>(FileInputStream.java:66) 
	at java.io.FileReader.<init>(FileReader.java:41) 
	at com.android.apicheck.ApiCheck.parseApi(ApiCheck.java:106) 
	at com.android.apicheck.ApiCheck.main(ApiCheck.java:88) 
out/target/common/obj/PACKAGING/public_api.xml: error 1: 
    out/target/common/obj/PACKAGING/public_api.xml (No such file or directory)

****************************** 
You have tried to change the API from what has been previously released in 
an SDK.  Please fix the errors listed above. 
****************************** 

\end{verbatim}


./build/core/version_defaults.mk:  PLATFORM_VERSION := AOSP 
./build/core/version_defaults.mk:  PLATFORM_VERSION_CODENAME := AOSP 



.jar   dx-->  .dex   
.so    要strip(去除调试符号，减少文件体积)  prelink (动态库预链接)
\subsubsection{制作镜像文件}
\begin{lstlisting}
out/host/linux-x86/bin/mkyaffs2image -f -c 4096 -s 128 out/target/product/e9/system out/target/product/e9/system.img
\end{lstlisting}
mkyaffs2image 会收影响,  Settings 在 asset里放了一个 html 文件, 烧 system.img
后, 发现弹出的对话框单选按钮不能选中. 拉出 /system/app/Setting.apk  , 发现 resource.arsc 的 CRC 校验失败, 而
out/target/product/e9/system/app/Setting.apk 是好的,  push到机器上, 运行正常的
.  删除了html,  烧入 system.img 无此现象.



\subsection{内核编译}

主要是模拟器的内核编译。
prebuilt/android-x86/kernel/kernel
\subsubsection{获取代码}
\begin{lstlisting}
~/Android$git clone git://android.git.kernel.org/kernel/common.git
~/Android$git checkout  origin/android-goldfish-2.6.27 -b goldfish
\end{lstlisting}
模拟器有自己的内核goldfish分支，默认分支编译后不能在qemu中启动。
更多的分支可以使用 git branch -a 查看。Goldfish 内核的源码导出到了目录~/Android/common

\subsubsection{交叉编译器}
这里使用的交叉编译器是 \href{
http://www.codesourcery.com/sgpp/lite/arm/portal/subscription?@template=lite}{CodeSourcery}
，也可以使用 Android 自带的交叉编译器 （在
prebuilt/linux-x86/toolchain/arm-eabi-4.4.0 ，相应的交叉编译器前缀要修改成
CROSS_COMPILE=arm-eabi-），当然把工具所在路径都要加入环境变量 PATH，在
~/.bashrc 加入：
\begin{lstlisting}
    export PATH=${PATH}:~/CodeSourcery/Sourcery_G++_Lite/bin
\end{lstlisting}

\subsubsection{编译配置}
\begin{enumerate}
    \item 从 SDK 中获取编译配置：
        \begin{lstlisting}
            $emulator -avd myavd      # 启动虚拟机, 或者在 Ecplise 把虚拟机启动
            $adb pull /proc/config.gz # 从虚拟机的文件系统中拉出内核的编译配置
            $gunzip config.gz;mv config ~/Android/common/.config
        \end{lstlisting}

    \item 从源码里直接配置： 
        \marginal{goldfish_defconfig 文件在目录 arch/arm/configs}
        \begin{lstlisting}
            $make ARCH=arm goldfish_defconfig       # 生成默认配置,
        \end{lstlisting}
    \end{enumerate}

    修改配置最常用的方法：
    \begin{enumerate}
        \item make xconfig     需要QT，安装libqt3-mt-dev 包即可
        \item make gconfig     需安装libglade2-dev
        \item make menuconfig
    \end{enumerate}
更详细的可以参照 README 或使用下面命令获取帮助：
        \begin{lstlisting}
            $make help
            $make ARCH=arm help
        \end{lstlisting}

            \subsubsection{修改 Makefile}
打开kernel目录下的Makefile文件，把
\begin{lstlisting}
    　　LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,
    　　$(call ld-option, -Wl$(comma)?build-id,))
\end{lstlisting}
　　这一行注释掉，并且添加一个空的LDFLAGS_BUILD_ID定义，如下:
\begin{lstlisting}LDFLAGS_BUILD_ID = \end{lstlisting}

\subsubsection{编译内核}
\begin{lstlisting}
    $make mrproper
    $make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-
\end{lstlisting}
编译开始，会有一些提示需要确认，一路回车键。小帖士：“［Y/n］”这样字样的含义是
，可以按“y”(yes)或者“n”(no)， 大写的”Y”表示用户默认的选择，即直接回车就是表示
选了”y”。

模拟器的内核编译的源码很少，很快就能编译完成，生成的kernel 镜像路径是
 arch/arm/boo/zImage， 拷贝到  prebuilt/android-arm/kernel/kernel-qemu  
 \begin{lstlisting}[language=] 
     make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- O=out/e9 -j4
     make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- menuconfig O=out/e9
 \end{lstlisting}
O 是代表编译的目录

\section{版本管理}

\subsection{备份文件好方法}
\begin{lstlisting}[escapeinside=]
find frameworks/base -ctime 0 -type f -print0 | xargs -0 -i cp {} ~/bk/
git archive master | bzip2 >~/note-latest-`date +"%y-%m-%d"`.tar.bz2
\end{lstlisting}

\subsection{git}

\begin{enumerate}
    \item 获取代码数据库
        \begin{lstlisting}[language=]
            #取内核的代码 
            $git clone git://android.git.kernel.org/kernel/common.git 
            $git clone git://android.git.kernel.org/kernel/linux-2.6.git 
            $git clone git://android.git.kernel.org/kernel/msm.git 

            #`如果另一个代码仓是从这个仓派生出来的可以使用--reference减少数据下载量`
            $git clone --reference ./linux-2.6 git://git.infradead.org/mtd-2.6 
        \end{lstlisting}

    \item 创建、删除分支
        \begin{lstlisting}[language=]
            $git branch robin    #创建分支robin
            $git branch -D robin # 删除分支  
            $git checkout robin  #`把HEAD切换到分支robin，注意此时没有
            修改，或修改以更新`
            $git checkout origin/master -b robin  #`检出分支origin/master 并命名为robin`
        \end{lstlisting}

    \item 查看分支
        \begin{lstlisting}[language=]
            $git branch        #查看当前分支
            * master 
            robin

            $git branch -a     #查看所有分支
            * master 
            remotes/origin/HEAD -> origin/master 
            remotes/origin/master 
            remotes/origin/qcom-dima-patches

            $git show-branch           #每个分支的世系发展状态， 每次提交的内容是否已进入每个分支。
            ! [local] aboot: handle new base address (0x20000000) for qsd8k 
            * [master] [msm7k] mddi support for msm7k and surf-msm7k wvga panel. 
            -- 
            +  [local] aboot: handle new base address (0x20000000) for qsd8k 
            +  [local^] msm: currently qsd8k has the dsp image below the kernel image 
            +  [local~2] msm: qsd8k has the shared memory region at a different address 
            +  [local~3] [msm] nand: Add a verify-after-write option. 
            +  [local~4] [surf7k/surf8k] fix flash partition table init. 
              +* [master] [msm7k] mddi support for msm7k and surf-msm7k wvga panel.
        \end{lstlisting}

    \item 查看代码的状态
        \begin{lstlisting}
            $git status 
        \end{lstlisting}
        如果没有修改的文件， 提示“nothing to commit (working directory clean)”。    
    \item 查看历史记录
        \begin{lstlisting}
            $git log                           #提交记录
        \end{lstlisting}
    \item 比较
        \begin{lstlisting} 
            $git diff      #比较当前的工作目录和版本库数据库中的差异。
        \end{lstlisting}
    \item 提交
        \begin{lstlisting}
            $git add .                #更新当前目录下的修改
            $git commit -m "change"   #提交修改
            $git add -n 
            $git add -p               #`与Patch一样，列出修改的内容，让用户确认要提交的修改。`
            $git add -i               #交互（Interactive）方式提交 
            $git add --amend          #附加提交， 即修改上次提交
        \end{lstlisting}

    \item 撤销、回退 
        \begin{lstlisting} 
            $git reset .              #重置更新，
            $git reset HEAD~3         #`回退3个提交,HEAD 是 git 的游标。 `
            $git checkout "@{2}" -f   #退回到倒数第2次提交 
            $git checkout -f makefile #放弃文件 makefile 的修改，从版本库中检出。
        \end{lstlisting}
\end{enumerate}

\subsubsection{git的一些配置}
git中文文件名、目录名乱码应该怎么解决？

通过看git的源码，找到了解决方案：

{\color{blue}git config core.quotepath false}

core.quotepath设为false的话，就不会对0x80以上的字符进行quote，中文显示正常。
或者在文件~/.gitconfig加入如下设置：
\begin{verbatim}
[core]
	quotepath = false
\end{verbatim}

\begin{lstlisting}[caption=git显示中文文件名的两种显示]
"Android \347\224\250\346\210\267\347\225\214\351\235\242\347\232\204\344\270\200\344\272\233\345\210\206\346\236\220.docx" 

Android 用户界面的一些分析.docx
\end{lstlisting} 
上面的第一个是使用了 quotepath，第二个没使用 quotepath

\begin{multicols}{2}
\begin{lstlisting}[caption=.gitconfig]
    [user]
	name = Xu shenlong
	email = xushenlong@szboeye.com 
    [color]
        diff = auto
        status = auto
        branch = auto
        interactive = auto
        ui = true
        pager = true 
    [color "branch"]
        current = yellow reverse
        local = yellow
        remote = green 
    [color "diff"]
        meta = yellow bold
        frag = magenta bold
        old = red bold
        new = green bold 
    [color "status"]
        added = yellow
        changed = green
        untracked = cyan 
    [core]
        quotepath = false
        pager = less -FRSX
        whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
    [alias]
        co = checkout
    [i18n]
	logoutputencoding=UTF-8
	commitencoding=UTF-8
\end{lstlisting}
\end{multicols}

\subsubsection{git tips}
\begin{lstlisting}[language=,]
    git checkout –t origin/<android-xyz-branch>

    work$ git status 
    # On branch master 
    # Changes to be committed: 
    #   (use "git reset HEAD <file>..." to unstage) 
    # 
    #	deleted:    "'\345\246\202\344\275\225\345\215\225\347\213\254build android app (\344\273\245launcher\344\270\272\344\276\213)'" 
    # 
    # Changed but not updated: 
    #   (use "git add/rm <file>..." to update what will be committed) 
    #   (use "git checkout -- <file>..." to discard changes in working directory) 
    # 
    #	deleted:    "Android\347\232\204ADB\345\267\245\345\205\267\344\275\277\347\224\250" 
    #	deleted:    "Android\347\232\204\350\260\203\350\257\225\345\216\237\347\220\206 -- \345\255\246\344\271\240\347\254\224\350\256\260" 
    # 
    work$ `git rm Android*ADB* `
    `rm 'Android的ADB工具使用'`
    work$ `git rm Anrdoid的*--*`
    `fatal: pathspec 'Anrdoid的*--*' did not match any files`
    work$ `git rm "Android的*--*"`
    `rm 'Android的调试原理--学习笔记'`
\end{lstlisting}



\subsection{repo}
Android 本身由多个子工程组成，每个工程都有自己的git代码仓库，为了方便对大量工程的管理，Google就写Python脚本repo 。
\begin{lstlisting}[language=]
$curl http://android.git.kernel.org/repo > ~/bin/repo
$chmod a+x ~/bin/repo
$mkdir working-directory-name
$cd working-directory-name

#取 Android 平台代码 
$repo init -u git://android.git.kernel.org/platform/manifest.git
$repo sync 

#取工具链代码 
$repo init -u git://android.git.kernel.org/toolchain/manifest.git 
$repo sync 

#工具链的代码不要与平台的代码放在一起。平台目录下的 prebuilt
#是针对内核和工具链等工程编译好的工具，所以一般我们可以不用自己下载、编译工具链
#代码。 

$repo forall -c git checkout remotes/korg/master
#借助 repo 工具，可以对批量工程执行同一个命令。但是这个命令取出来的代码不一致。

$repo init -u git://android.git.kernel.org/toolchain/manifest.git -b froyo
#能检出 Android 2.2 版本的代码。


repo init -b <branch>    
repo init -u git://android.git.kernel.org/platform/manifest.git && repo sync

repo init -b <branch> repo sync   
'repo forall -c git ...' fails at bootable project. 

repo forall -c git checkout android-2.3r1
\end{lstlisting}

\begin{quotation} \end{quotation}
Here's how I do it. It allows switching between dissimilar branches, and allows uploading the results.  
Lets say you are on froyo, and want to check out gingerbread-release, as you said: 

repo init -b gingerbread-release 

(answer the silly questions) 
repo sync (not needed if your local copy is up to date, but is needed the
first time, even if you already "repo sync" before the "repo init") 

repo start gingerbread-release --all 

That last command creates a branch for you to work on. Any time in the future
you check out that branch, you will get something based on the correct
version. 

repo checkout gingerbread-release 

You're good to go. If you want to upload anything to gerrit, you will need to
use "master" for your "repo init". Any time anything major changes (such as
now), you will also need to repeat the "repo start master --all" command. You
might need to erase the old master branch before you do. repo prune might be
your friends here. 

If you made a change in a non-master branch, and you want to upload it, just
use git in the project itself to transfer your changes between the branch and
the master branch, and then use repo to upload them as usual. 

Shachar 



\noindent\rule[-1ex]{\textwidth}{3pt}
\begin{thebibliography}{Reference}
    \bibitem {tiandroiddebug}\href{http://omappedia.org/wiki/Android_Debugging}{Android Debugging}
    \bibitem {androiddebugtools}\href{http://xy0811.spaces.live.com/Blog/cns!F8AECD2A067A6B17!1484.entry}{android的调试工具集}
    \bibitem {logwrapper} \href{http://hi.baidu.com/snownight/blog/item/91d55edfa2dc1f0149540399.html}{使用logwrapper调试Android程序}
    \bibitem {jdb-jdbshell} \href{http://www.limodev.cn/blog}{用jdb/jdbshell调试android程序}, 2009-11-18, 李先静
    \bibitem {Debugging Native Code}\href{http://source.android.com/porting/debugging_native.html}{Debugging Native Code}
    \bibitem {Debugging with GDB}\href{http://source.android.com/porting/debugging_gdb.html}{Debugging with GDB}
    \bibitem {toolbox} system/core/toolbox
    \bibitem {sh} system/core/sh
    \bibitem {lstdoc} /usr/share/texmf-texlive/tex/latex/listings/lstdoc.sty
\end{thebibliography}
\printindex
%E. M. A. C. S.
%* Emacs Makes A Computer Slow * Escape Meta Alt Control Shift
\end{document}
